# dependency_vulnerability_tracker.py - Track and monitor dependency vulnerabilities
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import os
import json
import requests
import threading
import subprocess
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
import re
import hashlib
from pathlib import Path

from base_tool import BaseToolFrame
from utils.security_utils import SecurityToolBase
from utils.database import DatabaseManager

TAB_NAME = "Dependency Vulnerability Tracker"

class ToolFrame(BaseToolFrame, SecurityToolBase):
    def __init__(self, master):
        BaseToolFrame.__init__(self, master)
        SecurityToolBase.__init__(self, "DependencyVulnerabilityTracker")
        
        self.db_manager = DatabaseManager()
        self.dependencies = []
        self.vulnerabilities = []
        self.monitoring_active = False
        self.setup_ui()
        self.load_cached_data()
        
    def setup_ui(self):
        """Setup the user interface"""
        # Main container
        main_frame = ttk.Frame(self)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Title
        title_label = ttk.Label(main_frame, text="Dependency Vulnerability Tracker", 
                               font=("Arial", 16, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Control panel
        control_frame = ttk.LabelFrame(main_frame, text="Control Panel", padding=10)
        control_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Project selection
        project_frame = ttk.Frame(control_frame)
        project_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(project_frame, text="Project Directory:").pack(side=tk.LEFT)
        self.project_var = tk.StringVar()
        self.project_entry = ttk.Entry(project_frame, textvariable=self.project_var, width=50)
        self.project_entry.pack(side=tk.LEFT, padx=(10, 5), fill=tk.X, expand=True)
        
        ttk.Button(project_frame, text="Browse", 
                  command=self.browse_project).pack(side=tk.RIGHT)
        
        # Scan options
        options_frame = ttk.Frame(control_frame)
        options_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.auto_update_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(options_frame, text="Auto-update vulnerability database", 
                       variable=self.auto_update_var).pack(side=tk.LEFT)
        
        self.include_dev_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(options_frame, text="Include dev dependencies", 
                       variable=self.include_dev_var).pack(side=tk.LEFT, padx=(20, 0))
        
        # Control buttons
        button_frame = ttk.Frame(control_frame)
        button_frame.pack(fill=tk.X, pady=(10, 0))
        
        self.scan_button = ttk.Button(button_frame, text="Scan Dependencies", 
                                     command=self.scan_dependencies)
        self.scan_button.pack(side=tk.LEFT)
        
        self.monitor_button = ttk.Button(button_frame, text="Start Monitoring", 
                                        command=self.toggle_monitoring)
        self.monitor_button.pack(side=tk.LEFT, padx=(10, 0))
        
        ttk.Button(button_frame, text="Update Database", 
                  command=self.update_vulnerability_database).pack(side=tk.LEFT, padx=(10, 0))
        
        ttk.Button(button_frame, text="Export Report", 
                  command=self.export_report).pack(side=tk.RIGHT)
        
        # Progress and status
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(main_frame, variable=self.progress_var, 
                                          maximum=100)
        self.progress_bar.pack(fill=tk.X, pady=(10, 0))
        
        self.status_var = tk.StringVar(value="Ready")
        status_label = ttk.Label(main_frame, textvariable=self.status_var)
        status_label.pack(pady=(5, 10))
        
        # Results notebook
        self.results_notebook = ttk.Notebook(main_frame)
        self.results_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Dependencies tab
        self.setup_dependencies_tab()
        
        # Vulnerabilities tab
        self.setup_vulnerabilities_tab()
        
        # Monitoring tab
        self.setup_monitoring_tab()
        
        # Reports tab
        self.setup_reports_tab()
        
    def setup_dependencies_tab(self):
        """Setup the dependencies overview tab"""
        deps_frame = ttk.Frame(self.results_notebook)
        self.results_notebook.add(deps_frame, text="Dependencies")
        
        # Dependencies treeview
        columns = ("Package", "Version", "Ecosystem", "Vulnerabilities", "Risk Level", "Last Checked")
        self.deps_tree = ttk.Treeview(deps_frame, columns=columns, show="headings", height=15)
        
        # Configure columns
        column_widths = {"Package": 150, "Version": 100, "Ecosystem": 80, 
                        "Vulnerabilities": 100, "Risk Level": 80, "Last Checked": 120}
        
        for col in columns:
            self.deps_tree.heading(col, text=col)
            self.deps_tree.column(col, width=column_widths.get(col, 100))
        
        # Scrollbars
        deps_scrollbar_y = ttk.Scrollbar(deps_frame, orient=tk.VERTICAL, 
                                        command=self.deps_tree.yview)
        deps_scrollbar_x = ttk.Scrollbar(deps_frame, orient=tk.HORIZONTAL, 
                                        command=self.deps_tree.xview)
        self.deps_tree.configure(yscrollcommand=deps_scrollbar_y.set, 
                                xscrollcommand=deps_scrollbar_x.set)
        
        # Pack treeview and scrollbars
        self.deps_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(10, 0), pady=10)
        deps_scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y, pady=10)
        
        # Bind events
        self.deps_tree.bind("<Double-1>", self.show_dependency_details)
        
    def setup_vulnerabilities_tab(self):
        """Setup the vulnerabilities tab"""
        vuln_frame = ttk.Frame(self.results_notebook)
        self.results_notebook.add(vuln_frame, text="Vulnerabilities")
        
        # Filter frame
        filter_frame = ttk.Frame(vuln_frame)
        filter_frame.pack(fill=tk.X, padx=10, pady=(10, 0))
        
        ttk.Label(filter_frame, text="Filter by severity:").pack(side=tk.LEFT)
        self.severity_filter_var = tk.StringVar(value="All")
        severity_combo = ttk.Combobox(filter_frame, textvariable=self.severity_filter_var,
                                     values=["All", "Critical", "High", "Medium", "Low"],
                                     state="readonly", width=10)
        severity_combo.pack(side=tk.LEFT, padx=(5, 0))
        severity_combo.bind("<<ComboboxSelected>>", self.filter_vulnerabilities)
        
        # Vulnerabilities treeview
        columns = ("CVE ID", "Package", "Severity", "Score", "Description", "Fixed Version")
        self.vuln_tree = ttk.Treeview(vuln_frame, columns=columns, show="headings", height=12)
        
        # Configure columns
        column_widths = {"CVE ID": 120, "Package": 120, "Severity": 80, 
                        "Score": 60, "Description": 200, "Fixed Version": 100}
        
        for col in columns:
            self.vuln_tree.heading(col, text=col)
            self.vuln_tree.column(col, width=column_widths.get(col, 100))
        
        # Scrollbars
        vuln_scrollbar_y = ttk.Scrollbar(vuln_frame, orient=tk.VERTICAL, 
                                        command=self.vuln_tree.yview)
        self.vuln_tree.configure(yscrollcommand=vuln_scrollbar_y.set)
        
        self.vuln_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(10, 0), pady=10)
        vuln_scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y, pady=10)
        
        # Bind events
        self.vuln_tree.bind("<Double-1>", self.show_vulnerability_details)
        
    def setup_monitoring_tab(self):
        """Setup the monitoring tab"""
        monitor_frame = ttk.Frame(self.results_notebook)
        self.results_notebook.add(monitor_frame, text="Monitoring")
        
        # Monitoring configuration
        config_frame = ttk.LabelFrame(monitor_frame, text="Monitoring Configuration", padding=10)
        config_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Check interval
        interval_frame = ttk.Frame(config_frame)
        interval_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(interval_frame, text="Check interval:").pack(side=tk.LEFT)
        self.check_interval_var = tk.StringVar(value="24")
        interval_spin = ttk.Spinbox(interval_frame, from_=1, to=168, 
                                   textvariable=self.check_interval_var, width=10)
        interval_spin.pack(side=tk.LEFT, padx=(10, 5))
        ttk.Label(interval_frame, text="hours").pack(side=tk.LEFT)
        
        # Notification settings
        self.email_notify_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(config_frame, text="Email notifications", 
                       variable=self.email_notify_var).pack(anchor=tk.W)
        
        self.critical_only_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(config_frame, text="Critical vulnerabilities only", 
                       variable=self.critical_only_var).pack(anchor=tk.W)
        
        # Monitoring log
        log_frame = ttk.LabelFrame(monitor_frame, text="Monitoring Log", padding=10)
        log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        self.monitor_log = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, height=10)
        self.monitor_log.pack(fill=tk.BOTH, expand=True)
        
    def setup_reports_tab(self):
        """Setup the reports tab"""
        reports_frame = ttk.Frame(self.results_notebook)
        self.results_notebook.add(reports_frame, text="Reports")
        
        # Report generation
        gen_frame = ttk.LabelFrame(reports_frame, text="Generate Report", padding=10)
        gen_frame.pack(fill=tk.X, padx=10, pady=10)
        
        report_types = [
            ("Executive Summary", "executive"),
            ("Technical Details", "technical"),
            ("Compliance Report", "compliance"),
            ("Trend Analysis", "trends")
        ]
        
        self.report_type_var = tk.StringVar(value="executive")
        for text, value in report_types:
            ttk.Radiobutton(gen_frame, text=text, variable=self.report_type_var, 
                           value=value).pack(anchor=tk.W)
        
        ttk.Button(gen_frame, text="Generate Report", 
                  command=self.generate_report).pack(pady=(10, 0))
        
        # Report preview
        preview_frame = ttk.LabelFrame(reports_frame, text="Report Preview", padding=10)
        preview_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        self.report_preview = scrolledtext.ScrolledText(preview_frame, wrap=tk.WORD)
        self.report_preview.pack(fill=tk.BOTH, expand=True)
        
    def browse_project(self):
        """Browse for project directory"""
        directory = filedialog.askdirectory(title="Select Project Directory")
        if directory:
            self.project_var.set(directory)
    
    def scan_dependencies(self):
        """Scan project dependencies for vulnerabilities"""
        project_path = self.project_var.get().strip()
        if not project_path or not os.path.exists(project_path):
            messagebox.showerror("Error", "Please select a valid project directory")
            return
        
        # Validate target for ethical scanning
        if not self.validate_and_authorize(project_path, "dependency_scan"):
            messagebox.showerror("Authorization Error", 
                               "Project not authorized for scanning. Check security logs.")
            return
        
        # Start scan in separate thread
        self.scan_thread = threading.Thread(target=self.run_dependency_scan, 
                                           args=(project_path,))
        self.scan_thread.daemon = True
        self.scan_thread.start()
        
        # Update UI state
        self.scan_button.config(state=tk.DISABLED)
        self.status_var.set("Scanning dependencies...")
        self.progress_var.set(0)
    
    def run_dependency_scan(self, project_path: str):
        """Run the dependency scan"""
        try:
            self.log_security_activity("DEPENDENCY_SCAN_STARTED", 
                                     f"Dependency scan started", project_path)
            
            # Clear previous results
            self.dependencies = []
            self.vulnerabilities = []
            
            # Scan different dependency files
            self.scan_python_dependencies(project_path)
            self.scan_npm_dependencies(project_path)
            self.scan_maven_dependencies(project_path)
            self.scan_composer_dependencies(project_path)
            
            # Check vulnerabilities for found dependencies
            self.check_all_vulnerabilities()
            
            # Update UI
            self.master.after(0, self.update_dependencies_ui)
            
            # Cache results
            self.cache_scan_results()
            
            self.log_security_activity("DEPENDENCY_SCAN_COMPLETED", 
                                     f"Found {len(self.dependencies)} dependencies, {len(self.vulnerabilities)} vulnerabilities", 
                                     project_path)
            
        except Exception as e:
            self.log_security_activity("DEPENDENCY_SCAN_ERROR", f"Scan error: {str(e)}", project_path)
            self.master.after(0, lambda: messagebox.showerror("Scan Error", str(e)))
        
        finally:
            # Reset UI state
            self.master.after(0, self.reset_scan_ui)
    
    def scan_python_dependencies(self, project_path: str):
        """Scan Python dependencies"""
        self.master.after(0, lambda: self.status_var.set("Scanning Python dependencies..."))
        
        # Look for requirements files
        req_files = []
        for root, dirs, files in os.walk(project_path):
            for file in files:
                if file in ['requirements.txt', 'requirements-dev.txt', 'Pipfile', 'pyproject.toml']:
                    req_files.append(os.path.join(root, file))
        
        for req_file in req_files:
            try:
                if req_file.endswith('requirements.txt') or req_file.endswith('requirements-dev.txt'):
                    self.parse_requirements_txt(req_file)
                elif req_file.endswith('Pipfile'):
                    self.parse_pipfile(req_file)
                elif req_file.endswith('pyproject.toml'):
                    self.parse_pyproject_toml(req_file)
            except Exception as e:
                self.log_security_activity("PYTHON_PARSE_ERROR", 
                                         f"Error parsing {req_file}: {str(e)}")
        
        self.master.after(0, lambda: self.progress_var.set(25))
    
    def parse_requirements_txt(self, file_path: str):
        """Parse requirements.txt file"""
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        for line_num, line in enumerate(lines, 1):
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            # Parse package specification
            package_info = self.parse_python_requirement(line)
            if package_info:
                dependency = {
                    "name": package_info["name"],
                    "version": package_info["version"],
                    "ecosystem": "Python",
                    "file": file_path,
                    "line": line_num,
                    "specification": line,
                    "last_checked": datetime.now().isoformat()
                }
                self.dependencies.append(dependency)
    
    def parse_python_requirement(self, requirement: str) -> Optional[Dict]:
        """Parse Python requirement string"""
        # Handle different requirement formats
        patterns = [
            r'^([a-zA-Z0-9_-]+)([>=<!=]+)([\d.]+)',  # package>=1.0.0
            r'^([a-zA-Z0-9_-]+)==([\d.]+)',          # package==1.0.0
            r'^([a-zA-Z0-9_-]+)$'                    # package (latest)
        ]
        
        for pattern in patterns:
            match = re.match(pattern, requirement.strip())
            if match:
                groups = match.groups()
                return {
                    "name": groups[0],
                    "operator": groups[1] if len(groups) > 2 else "==",
                    "version": groups[-1] if len(groups) > 1 else "latest"
                }
        return None
    
    def parse_pipfile(self, file_path: str):
        """Parse Pipfile"""
        # Simple Pipfile parsing - would need toml library for full support
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Extract package names (simplified)
            package_pattern = r'([a-zA-Z0-9_-]+)\s*=\s*"([^"]+)"'
            matches = re.findall(package_pattern, content)
            
            for package_name, version_spec in matches:
                dependency = {
                    "name": package_name,
                    "version": version_spec.strip('"'),
                    "ecosystem": "Python",
                    "file": file_path,
                    "line": 0,
                    "specification": f"{package_name} = \"{version_spec}\"",
                    "last_checked": datetime.now().isoformat()
                }
                self.dependencies.append(dependency)
                
        except Exception as e:
            self.log_security_activity("PIPFILE_PARSE_ERROR", f"Error parsing Pipfile: {str(e)}")
    
    def parse_pyproject_toml(self, file_path: str):
        """Parse pyproject.toml file"""
        # Simplified parsing - would need toml library for full support
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Look for dependencies section
            if '[tool.poetry.dependencies]' in content or 'dependencies = [' in content:
                # Extract dependencies (simplified)
                dep_pattern = r'([a-zA-Z0-9_-]+)\s*=\s*"([^"]+)"'
                matches = re.findall(dep_pattern, content)
                
                for package_name, version_spec in matches:
                    if package_name != 'python':  # Skip Python version
                        dependency = {
                            "name": package_name,
                            "version": version_spec,
                            "ecosystem": "Python",
                            "file": file_path,
                            "line": 0,
                            "specification": f"{package_name} = \"{version_spec}\"",
                            "last_checked": datetime.now().isoformat()
                        }
                        self.dependencies.append(dependency)
                        
        except Exception as e:
            self.log_security_activity("PYPROJECT_PARSE_ERROR", f"Error parsing pyproject.toml: {str(e)}")
    
    def scan_npm_dependencies(self, project_path: str):
        """Scan NPM dependencies"""
        self.master.after(0, lambda: self.status_var.set("Scanning NPM dependencies..."))
        
        package_files = []
        for root, dirs, files in os.walk(project_path):
            if 'package.json' in files:
                package_files.append(os.path.join(root, 'package.json'))
        
        for package_file in package_files:
            try:
                with open(package_file, 'r') as f:
                    package_data = json.load(f)
                
                # Regular dependencies
                dependencies = package_data.get('dependencies', {})
                for name, version in dependencies.items():
                    dependency = {
                        "name": name,
                        "version": version,
                        "ecosystem": "NPM",
                        "file": package_file,
                        "line": 0,
                        "specification": f"{name}: {version}",
                        "last_checked": datetime.now().isoformat()
                    }
                    self.dependencies.append(dependency)
                
                # Dev dependencies (if enabled)
                if self.include_dev_var.get():
                    dev_dependencies = package_data.get('devDependencies', {})
                    for name, version in dev_dependencies.items():
                        dependency = {
                            "name": name,
                            "version": version,
                            "ecosystem": "NPM",
                            "file": package_file,
                            "line": 0,
                            "specification": f"{name}: {version} (dev)",
                            "last_checked": datetime.now().isoformat()
                        }
                        self.dependencies.append(dependency)
                        
            except Exception as e:
                self.log_security_activity("NPM_PARSE_ERROR", 
                                         f"Error parsing {package_file}: {str(e)}")
        
        self.master.after(0, lambda: self.progress_var.set(50))
    
    def scan_maven_dependencies(self, project_path: str):
        """Scan Maven dependencies"""
        self.master.after(0, lambda: self.status_var.set("Scanning Maven dependencies..."))
        
        pom_files = []
        for root, dirs, files in os.walk(project_path):
            if 'pom.xml' in files:
                pom_files.append(os.path.join(root, 'pom.xml'))
        
        for pom_file in pom_files:
            try:
                # Simple XML parsing for Maven dependencies
                with open(pom_file, 'r') as f:
                    content = f.read()
                
                # Extract dependencies (simplified regex approach)
                dep_pattern = r'<dependency>.*?<groupId>([^<]+)</groupId>.*?<artifactId>([^<]+)</artifactId>.*?<version>([^<]+)</version>.*?</dependency>'
                matches = re.findall(dep_pattern, content, re.DOTALL)
                
                for group_id, artifact_id, version in matches:
                    dependency = {
                        "name": f"{group_id}:{artifact_id}",
                        "version": version,
                        "ecosystem": "Maven",
                        "file": pom_file,
                        "line": 0,
                        "specification": f"{group_id}:{artifact_id}:{version}",
                        "last_checked": datetime.now().isoformat()
                    }
                    self.dependencies.append(dependency)
                    
            except Exception as e:
                self.log_security_activity("MAVEN_PARSE_ERROR", 
                                         f"Error parsing {pom_file}: {str(e)}")
        
        self.master.after(0, lambda: self.progress_var.set(75))
    
    def scan_composer_dependencies(self, project_path: str):
        """Scan Composer dependencies (PHP)"""
        self.master.after(0, lambda: self.status_var.set("Scanning Composer dependencies..."))
        
        composer_files = []
        for root, dirs, files in os.walk(project_path):
            if 'composer.json' in files:
                composer_files.append(os.path.join(root, 'composer.json'))
        
        for composer_file in composer_files:
            try:
                with open(composer_file, 'r') as f:
                    composer_data = json.load(f)
                
                # Regular dependencies
                dependencies = composer_data.get('require', {})
                for name, version in dependencies.items():
                    if name != 'php':  # Skip PHP version
                        dependency = {
                            "name": name,
                            "version": version,
                            "ecosystem": "Composer",
                            "file": composer_file,
                            "line": 0,
                            "specification": f"{name}: {version}",
                            "last_checked": datetime.now().isoformat()
                        }
                        self.dependencies.append(dependency)
                
                # Dev dependencies (if enabled)
                if self.include_dev_var.get():
                    dev_dependencies = composer_data.get('require-dev', {})
                    for name, version in dev_dependencies.items():
                        dependency = {
                            "name": name,
                            "version": version,
                            "ecosystem": "Composer",
                            "file": composer_file,
                            "line": 0,
                            "specification": f"{name}: {version} (dev)",
                            "last_checked": datetime.now().isoformat()
                        }
                        self.dependencies.append(dependency)
                        
            except Exception as e:
                self.log_security_activity("COMPOSER_PARSE_ERROR", 
                                         f"Error parsing {composer_file}: {str(e)}")
        
        self.master.after(0, lambda: self.progress_var.set(90))
    
    def check_all_vulnerabilities(self):
        """Check all dependencies for vulnerabilities"""
        self.master.after(0, lambda: self.status_var.set("Checking vulnerabilities..."))
        
        for dependency in self.dependencies:
            vulnerabilities = self.check_dependency_vulnerabilities(
                dependency["name"], dependency["version"], dependency["ecosystem"]
            )
            
            for vuln in vulnerabilities:
                vuln["dependency"] = dependency
                self.vulnerabilities.append(vuln)
        
        self.master.after(0, lambda: self.progress_var.set(100))
    
    def check_dependency_vulnerabilities(self, package_name: str, version: str, 
                                       ecosystem: str) -> List[Dict]:
        """Check a specific dependency for vulnerabilities"""
        # This is a mock implementation
        # In a real implementation, you would query actual vulnerability databases
        # like OSV, NVD, Snyk, etc.
        
        vulnerabilities = []
        
        # Mock vulnerability data for demonstration
        mock_vulns = {
            "requests": {
                "2.25.0": [
                    {
                        "cve_id": "CVE-2021-33503",
                        "severity": "High",
                        "score": 7.5,
                        "description": "Catastrophic backtracking in URL parsing",
                        "fixed_version": "2.25.1",
                        "published_date": "2021-06-29",
                        "references": ["https://nvd.nist.gov/vuln/detail/CVE-2021-33503"]
                    }
                ]
            },
            "django": {
                "3.1.0": [
                    {
                        "cve_id": "CVE-2021-35042",
                        "severity": "Medium",
                        "score": 5.3,
                        "description": "Potential directory traversal via uploaded files",
                        "fixed_version": "3.1.13",
                        "published_date": "2021-07-02",
                        "references": ["https://nvd.nist.gov/vuln/detail/CVE-2021-35042"]
                    }
                ]
            },
            "lodash": {
                "4.17.15": [
                    {
                        "cve_id": "CVE-2020-8203",
                        "severity": "High",
                        "score": 7.4,
                        "description": "Prototype pollution vulnerability",
                        "fixed_version": "4.17.19",
                        "published_date": "2020-07-15",
                        "references": ["https://nvd.nist.gov/vuln/detail/CVE-2020-8203"]
                    }
                ]
            }
        }
        
        # Check if package has known vulnerabilities
        if package_name in mock_vulns:
            package_vulns = mock_vulns[package_name]
            
            # Check if version matches vulnerable versions
            if version in package_vulns:
                vulnerabilities.extend(package_vulns[version])
            elif version == "latest" or version.startswith("^") or version.startswith("~"):
                # For flexible version specs, assume vulnerable
                for vuln_version, vulns in package_vulns.items():
                    vulnerabilities.extend(vulns)
        
        return vulnerabilities  
  
    def update_dependencies_ui(self):
        """Update the dependencies UI with scan results"""
        # Clear previous results
        for item in self.deps_tree.get_children():
            self.deps_tree.delete(item)
        
        for item in self.vuln_tree.get_children():
            self.vuln_tree.delete(item)
        
        # Update dependencies tree
        for dependency in self.dependencies:
            # Count vulnerabilities for this dependency
            dep_vulns = [v for v in self.vulnerabilities 
                        if v["dependency"]["name"] == dependency["name"]]
            
            vuln_count = len(dep_vulns)
            risk_level = self.calculate_risk_level(dep_vulns)
            
            self.deps_tree.insert("", tk.END, values=(
                dependency["name"],
                dependency["version"],
                dependency["ecosystem"],
                vuln_count,
                risk_level,
                dependency["last_checked"][:10]  # Date only
            ))
        
        # Update vulnerabilities tree
        self.update_vulnerabilities_tree()
        
        # Update status
        self.status_var.set(f"Found {len(self.dependencies)} dependencies, {len(self.vulnerabilities)} vulnerabilities")
    
    def calculate_risk_level(self, vulnerabilities: List[Dict]) -> str:
        """Calculate overall risk level for a dependency"""
        if not vulnerabilities:
            return "Low"
        
        severities = [v.get("severity", "Low") for v in vulnerabilities]
        
        if "Critical" in severities:
            return "Critical"
        elif "High" in severities:
            return "High"
        elif "Medium" in severities:
            return "Medium"
        else:
            return "Low"
    
    def update_vulnerabilities_tree(self):
        """Update the vulnerabilities tree view"""
        # Apply severity filter
        severity_filter = self.severity_filter_var.get()
        
        for vulnerability in self.vulnerabilities:
            if (severity_filter == "All" or 
                vulnerability.get("severity") == severity_filter):
                
                self.vuln_tree.insert("", tk.END, values=(
                    vulnerability.get("cve_id", "N/A"),
                    vulnerability["dependency"]["name"],
                    vulnerability.get("severity", "Unknown"),
                    vulnerability.get("score", "N/A"),
                    vulnerability.get("description", "")[:50] + "...",
                    vulnerability.get("fixed_version", "N/A")
                ))
    
    def filter_vulnerabilities(self, event=None):
        """Filter vulnerabilities by severity"""
        self.update_vulnerabilities_tree()
    
    def show_dependency_details(self, event):
        """Show detailed information about selected dependency"""
        selection = self.deps_tree.selection()
        if not selection:
            return
        
        item = self.deps_tree.item(selection[0])
        values = item['values']
        package_name = values[0]
        
        # Find the dependency
        dependency = None
        for dep in self.dependencies:
            if dep["name"] == package_name:
                dependency = dep
                break
        
        if dependency:
            self.show_dependency_popup(dependency)
    
    def show_dependency_popup(self, dependency: Dict):
        """Show detailed dependency information in popup"""
        popup = tk.Toplevel(self.master)
        popup.title(f"Dependency Details - {dependency['name']}")
        popup.geometry("600x500")
        
        # Create notebook for different tabs
        notebook = ttk.Notebook(popup)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # General info tab
        info_frame = ttk.Frame(notebook)
        notebook.add(info_frame, text="General Info")
        
        info_text = scrolledtext.ScrolledText(info_frame, wrap=tk.WORD)
        info_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        info_content = f"Dependency Information\n"
        info_content += "=" * 50 + "\n\n"
        info_content += f"Name: {dependency['name']}\n"
        info_content += f"Version: {dependency['version']}\n"
        info_content += f"Ecosystem: {dependency['ecosystem']}\n"
        info_content += f"File: {dependency['file']}\n"
        info_content += f"Specification: {dependency['specification']}\n"
        info_content += f"Last Checked: {dependency['last_checked']}\n\n"
        
        # Find vulnerabilities for this dependency
        dep_vulns = [v for v in self.vulnerabilities 
                    if v["dependency"]["name"] == dependency["name"]]
        
        if dep_vulns:
            info_content += f"Vulnerabilities Found: {len(dep_vulns)}\n"
            info_content += f"Risk Level: {self.calculate_risk_level(dep_vulns)}\n"
        else:
            info_content += "No known vulnerabilities found.\n"
        
        info_text.insert(tk.END, info_content)
        info_text.config(state=tk.DISABLED)
        
        # Vulnerabilities tab
        if dep_vulns:
            vuln_frame = ttk.Frame(notebook)
            notebook.add(vuln_frame, text="Vulnerabilities")
            
            vuln_text = scrolledtext.ScrolledText(vuln_frame, wrap=tk.WORD)
            vuln_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            vuln_content = "Vulnerabilities\n"
            vuln_content += "=" * 50 + "\n\n"
            
            for i, vuln in enumerate(dep_vulns, 1):
                vuln_content += f"Vulnerability #{i}\n"
                vuln_content += "-" * 20 + "\n"
                vuln_content += f"CVE ID: {vuln.get('cve_id', 'N/A')}\n"
                vuln_content += f"Severity: {vuln.get('severity', 'Unknown')}\n"
                vuln_content += f"Score: {vuln.get('score', 'N/A')}\n"
                vuln_content += f"Description: {vuln.get('description', 'No description')}\n"
                vuln_content += f"Fixed Version: {vuln.get('fixed_version', 'N/A')}\n"
                vuln_content += f"Published: {vuln.get('published_date', 'N/A')}\n\n"
            
            vuln_text.insert(tk.END, vuln_content)
            vuln_text.config(state=tk.DISABLED)
    
    def show_vulnerability_details(self, event):
        """Show detailed vulnerability information"""
        selection = self.vuln_tree.selection()
        if not selection:
            return
        
        item = self.vuln_tree.item(selection[0])
        values = item['values']
        cve_id = values[0]
        
        # Find the vulnerability
        vulnerability = None
        for vuln in self.vulnerabilities:
            if vuln.get("cve_id") == cve_id:
                vulnerability = vuln
                break
        
        if vulnerability:
            self.show_vulnerability_popup(vulnerability)
    
    def show_vulnerability_popup(self, vulnerability: Dict):
        """Show detailed vulnerability information in popup"""
        popup = tk.Toplevel(self.master)
        popup.title(f"Vulnerability Details - {vulnerability.get('cve_id', 'Unknown')}")
        popup.geometry("600x500")
        
        text_widget = scrolledtext.ScrolledText(popup, wrap=tk.WORD)
        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        details = f"Vulnerability Details\n"
        details += "=" * 50 + "\n\n"
        details += f"CVE ID: {vulnerability.get('cve_id', 'N/A')}\n"
        details += f"Affected Package: {vulnerability['dependency']['name']}\n"
        details += f"Package Version: {vulnerability['dependency']['version']}\n"
        details += f"Severity: {vulnerability.get('severity', 'Unknown')}\n"
        details += f"CVSS Score: {vulnerability.get('score', 'N/A')}\n"
        details += f"Published Date: {vulnerability.get('published_date', 'N/A')}\n\n"
        details += f"Description:\n{vulnerability.get('description', 'No description available')}\n\n"
        details += f"Fixed Version: {vulnerability.get('fixed_version', 'Not available')}\n\n"
        
        if vulnerability.get('references'):
            details += "References:\n"
            for ref in vulnerability['references']:
                details += f"- {ref}\n"
        
        text_widget.insert(tk.END, details)
        text_widget.config(state=tk.DISABLED)
    
    def toggle_monitoring(self):
        """Toggle dependency monitoring"""
        if not self.monitoring_active:
            self.start_monitoring()
        else:
            self.stop_monitoring()
    
    def start_monitoring(self):
        """Start continuous monitoring"""
        self.monitoring_active = True
        self.monitor_button.config(text="Stop Monitoring")
        
        # Log monitoring start
        self.log_monitoring("Monitoring started")
        
        # Schedule periodic checks
        self.schedule_next_check()
    
    def stop_monitoring(self):
        """Stop continuous monitoring"""
        self.monitoring_active = False
        self.monitor_button.config(text="Start Monitoring")
        
        # Log monitoring stop
        self.log_monitoring("Monitoring stopped")
    
    def schedule_next_check(self):
        """Schedule the next vulnerability check"""
        if not self.monitoring_active:
            return
        
        # Get check interval in milliseconds
        interval_hours = int(self.check_interval_var.get())
        interval_ms = interval_hours * 60 * 60 * 1000
        
        # Schedule next check
        self.master.after(interval_ms, self.perform_scheduled_check)
    
    def perform_scheduled_check(self):
        """Perform scheduled vulnerability check"""
        if not self.monitoring_active:
            return
        
        self.log_monitoring("Performing scheduled vulnerability check")
        
        # Re-check vulnerabilities for existing dependencies
        old_vuln_count = len(self.vulnerabilities)
        self.vulnerabilities = []
        self.check_all_vulnerabilities()
        new_vuln_count = len(self.vulnerabilities)
        
        # Check for new vulnerabilities
        if new_vuln_count > old_vuln_count:
            new_vulns = new_vuln_count - old_vuln_count
            self.log_monitoring(f"Found {new_vulns} new vulnerabilities")
            
            # Send notifications if enabled
            if self.email_notify_var.get():
                self.send_notification(new_vulns)
        
        # Update UI
        self.master.after(0, self.update_dependencies_ui)
        
        # Schedule next check
        self.schedule_next_check()
    
    def log_monitoring(self, message: str):
        """Log monitoring activity"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {message}\n"
        
        self.monitor_log.insert(tk.END, log_entry)
        self.monitor_log.see(tk.END)
        
        # Also log to security audit
        self.log_security_activity("MONITORING", message)
    
    def send_notification(self, new_vuln_count: int):
        """Send notification about new vulnerabilities"""
        # This would implement actual notification sending
        # For now, just log the notification
        self.log_monitoring(f"Notification: {new_vuln_count} new vulnerabilities detected")
    
    def update_vulnerability_database(self):
        """Update the vulnerability database"""
        if not self.auto_update_var.get():
            response = messagebox.askyesno("Update Database", 
                                         "Update vulnerability database? This may take some time.")
            if not response:
                return
        
        # Start update in separate thread
        update_thread = threading.Thread(target=self.run_database_update)
        update_thread.daemon = True
        update_thread.start()
        
        self.status_var.set("Updating vulnerability database...")
    
    def run_database_update(self):
        """Run database update in background"""
        try:
            self.log_security_activity("DATABASE_UPDATE_STARTED", "Vulnerability database update started")
            
            # Mock database update - in real implementation, this would:
            # - Download latest CVE data
            # - Update local vulnerability database
            # - Refresh package vulnerability mappings
            
            import time
            for i in range(10):
                if i % 2 == 0:
                    self.master.after(0, lambda p=i*10: self.progress_var.set(p))
                time.sleep(0.5)  # Simulate update time
            
            self.master.after(0, lambda: self.progress_var.set(100))
            self.master.after(0, lambda: self.status_var.set("Database update completed"))
            
            self.log_security_activity("DATABASE_UPDATE_COMPLETED", "Vulnerability database update completed")
            
        except Exception as e:
            self.log_security_activity("DATABASE_UPDATE_ERROR", f"Database update error: {str(e)}")
            self.master.after(0, lambda: messagebox.showerror("Update Error", str(e)))
    
    def generate_report(self):
        """Generate vulnerability report"""
        report_type = self.report_type_var.get()
        
        if report_type == "executive":
            report = self.generate_executive_report()
        elif report_type == "technical":
            report = self.generate_technical_report()
        elif report_type == "compliance":
            report = self.generate_compliance_report()
        elif report_type == "trends":
            report = self.generate_trends_report()
        else:
            report = "Unknown report type"
        
        # Display report in preview
        self.report_preview.delete(1.0, tk.END)
        self.report_preview.insert(tk.END, report)
    
    def generate_executive_report(self) -> str:
        """Generate executive summary report"""
        report = "EXECUTIVE SUMMARY - DEPENDENCY VULNERABILITY REPORT\n"
        report += "=" * 60 + "\n\n"
        
        # Summary statistics
        total_deps = len(self.dependencies)
        total_vulns = len(self.vulnerabilities)
        vulnerable_deps = len(set(v["dependency"]["name"] for v in self.vulnerabilities))
        
        report += f"Total Dependencies Scanned: {total_deps}\n"
        report += f"Dependencies with Vulnerabilities: {vulnerable_deps}\n"
        report += f"Total Vulnerabilities Found: {total_vulns}\n\n"
        
        # Risk breakdown
        risk_counts = {}
        for vuln in self.vulnerabilities:
            severity = vuln.get("severity", "Unknown")
            risk_counts[severity] = risk_counts.get(severity, 0) + 1
        
        report += "RISK BREAKDOWN:\n"
        report += "-" * 20 + "\n"
        for severity in ["Critical", "High", "Medium", "Low"]:
            count = risk_counts.get(severity, 0)
            report += f"{severity}: {count}\n"
        
        report += "\nRECOMMENDATIONS:\n"
        report += "-" * 20 + "\n"
        
        critical_high = risk_counts.get("Critical", 0) + risk_counts.get("High", 0)
        if critical_high > 0:
            report += f"• IMMEDIATE ACTION: Address {critical_high} critical/high severity vulnerabilities\n"
        
        report += "• Implement automated dependency scanning in CI/CD pipeline\n"
        report += "• Establish regular dependency update schedule\n"
        report += "• Monitor for new vulnerabilities continuously\n"
        
        return report
    
    def generate_technical_report(self) -> str:
        """Generate technical details report"""
        report = "TECHNICAL VULNERABILITY REPORT\n"
        report += "=" * 40 + "\n\n"
        
        # Group vulnerabilities by package
        vuln_by_package = {}
        for vuln in self.vulnerabilities:
            package_name = vuln["dependency"]["name"]
            if package_name not in vuln_by_package:
                vuln_by_package[package_name] = []
            vuln_by_package[package_name].append(vuln)
        
        for package_name, vulns in vuln_by_package.items():
            report += f"PACKAGE: {package_name}\n"
            report += "-" * 30 + "\n"
            
            for vuln in vulns:
                report += f"CVE: {vuln.get('cve_id', 'N/A')}\n"
                report += f"Severity: {vuln.get('severity', 'Unknown')}\n"
                report += f"Score: {vuln.get('score', 'N/A')}\n"
                report += f"Description: {vuln.get('description', 'No description')}\n"
                report += f"Fixed Version: {vuln.get('fixed_version', 'N/A')}\n"
                report += "\n"
            
            report += "\n"
        
        return report
    
    def generate_compliance_report(self) -> str:
        """Generate compliance report"""
        report = "COMPLIANCE VULNERABILITY REPORT\n"
        report += "=" * 40 + "\n\n"
        
        report += "This report provides vulnerability information for compliance purposes.\n\n"
        
        # Compliance metrics
        total_deps = len(self.dependencies)
        vulnerable_deps = len(set(v["dependency"]["name"] for v in self.vulnerabilities))
        compliance_score = ((total_deps - vulnerable_deps) / total_deps * 100) if total_deps > 0 else 100
        
        report += f"Compliance Score: {compliance_score:.1f}%\n"
        report += f"Dependencies without known vulnerabilities: {total_deps - vulnerable_deps}/{total_deps}\n\n"
        
        # Critical vulnerabilities (compliance risk)
        critical_vulns = [v for v in self.vulnerabilities if v.get("severity") == "Critical"]
        if critical_vulns:
            report += "CRITICAL VULNERABILITIES (IMMEDIATE COMPLIANCE RISK):\n"
            report += "-" * 50 + "\n"
            for vuln in critical_vulns:
                report += f"• {vuln['dependency']['name']}: {vuln.get('cve_id', 'N/A')}\n"
            report += "\n"
        
        return report
    
    def generate_trends_report(self) -> str:
        """Generate trends analysis report"""
        report = "VULNERABILITY TRENDS REPORT\n"
        report += "=" * 35 + "\n\n"
        
        report += "This report would show vulnerability trends over time.\n"
        report += "Historical data collection is required for trend analysis.\n\n"
        
        # Mock trend data
        report += "TREND INDICATORS:\n"
        report += "-" * 20 + "\n"
        report += "• New vulnerabilities discovered: Increasing\n"
        report += "• Time to patch: Average 14 days\n"
        report += "• Most vulnerable ecosystem: NPM\n"
        report += "• Recommendation: Implement automated patching\n"
        
        return report
    
    def export_report(self):
        """Export vulnerability report"""
        if not self.dependencies:
            messagebox.showwarning("No Data", "No dependency data to export")
            return
        
        file_path = filedialog.asksaveasfilename(
            title="Export Vulnerability Report",
            defaultextension=".json",
            filetypes=[
                ("JSON files", "*.json"),
                ("CSV files", "*.csv"),
                ("Text files", "*.txt")
            ]
        )
        
        if not file_path:
            return
        
        try:
            if file_path.endswith('.json'):
                self.export_json_report(file_path)
            elif file_path.endswith('.csv'):
                self.export_csv_report(file_path)
            else:
                self.export_text_report(file_path)
            
            messagebox.showinfo("Export Complete", f"Report exported to {file_path}")
            
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export report: {str(e)}")
    
    def export_json_report(self, file_path: str):
        """Export report as JSON"""
        report_data = {
            "metadata": {
                "generated_at": datetime.now().isoformat(),
                "project_path": self.project_var.get(),
                "total_dependencies": len(self.dependencies),
                "total_vulnerabilities": len(self.vulnerabilities)
            },
            "dependencies": self.dependencies,
            "vulnerabilities": self.vulnerabilities
        }
        
        with open(file_path, 'w') as f:
            json.dump(report_data, f, indent=2)
    
    def export_csv_report(self, file_path: str):
        """Export report as CSV"""
        import csv
        
        with open(file_path, 'w', newline='') as f:
            writer = csv.writer(f)
            
            # Write header
            writer.writerow([
                "Package", "Version", "Ecosystem", "CVE ID", "Severity", 
                "Score", "Description", "Fixed Version", "File"
            ])
            
            # Write vulnerability data
            for vuln in self.vulnerabilities:
                dep = vuln["dependency"]
                writer.writerow([
                    dep["name"],
                    dep["version"],
                    dep["ecosystem"],
                    vuln.get("cve_id", ""),
                    vuln.get("severity", ""),
                    vuln.get("score", ""),
                    vuln.get("description", ""),
                    vuln.get("fixed_version", ""),
                    dep["file"]
                ])
    
    def export_text_report(self, file_path: str):
        """Export report as text"""
        with open(file_path, 'w') as f:
            f.write(self.generate_technical_report())
    
    def cache_scan_results(self):
        """Cache scan results to database"""
        try:
            # This would save results to database for historical tracking
            cache_data = {
                "timestamp": datetime.now().isoformat(),
                "project_path": self.project_var.get(),
                "dependencies": self.dependencies,
                "vulnerabilities": self.vulnerabilities
            }
            
            # Mock database save
            self.log_security_activity("RESULTS_CACHED", f"Cached {len(self.dependencies)} dependencies")
            
        except Exception as e:
            self.log_security_activity("CACHE_ERROR", f"Error caching results: {str(e)}")
    
    def load_cached_data(self):
        """Load previously cached scan results"""
        try:
            # This would load from database
            # For now, just initialize empty
            self.dependencies = []
            self.vulnerabilities = []
            
        except Exception as e:
            self.log_security_activity("CACHE_LOAD_ERROR", f"Error loading cached data: {str(e)}")
    
    def reset_scan_ui(self):
        """Reset UI state after scan completion"""
        self.scan_button.config(state=tk.NORMAL)
        self.is_authorized = False  # Reset authorization


# Tool registration
def create_tool(master):
    return DependencyVulnerabilityTracker(master)

if __name__ == "__main__":
    # Test the tool
    root = tk.Tk()
    tool = DependencyVulnerabilityTracker(root)
    root.mainloop()