# security_vulnerability_scanner.py - OWASP Top 10 vulnerability detection and CVE analysis
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import os
import re
import json
import ast
import requests
import threading
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
import subprocess
import hashlib
from pathlib import Path

from base_tool import BaseToolFrame
from utils.security_utils import SecurityToolBase
from utils.database import DatabaseManager

TAB_NAME = "Security Vulnerability Scanner"

class SecurityVulnerabilityScanner(BaseToolFrame, SecurityToolBase):
    def __init__(self, master):
        BaseToolFrame.__init__(self, master)
        SecurityToolBase.__init__(self, "SecurityVulnerabilityScanner")
        
        self.db_manager = DatabaseManager()
        self.scan_results = []
        self.vulnerability_patterns = self.load_vulnerability_patterns()
        self.cve_cache = {}
        self.setup_ui()
        
    def setup_ui(self):
        """Setup the user interface"""
        # Main container
        main_frame = ttk.Frame(self)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Title
        title_label = ttk.Label(main_frame, text="Security Vulnerability Scanner", 
                               font=("Arial", 16, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Scan configuration frame
        config_frame = ttk.LabelFrame(main_frame, text="Scan Configuration", padding=10)
        config_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Target selection
        target_frame = ttk.Frame(config_frame)
        target_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(target_frame, text="Target:").pack(side=tk.LEFT)
        self.target_var = tk.StringVar()
        self.target_entry = ttk.Entry(target_frame, textvariable=self.target_var, width=50)
        self.target_entry.pack(side=tk.LEFT, padx=(10, 5), fill=tk.X, expand=True)
        
        ttk.Button(target_frame, text="Browse", 
                  command=self.browse_target).pack(side=tk.RIGHT)
        
        # Scan type selection
        scan_type_frame = ttk.Frame(config_frame)
        scan_type_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(scan_type_frame, text="Scan Type:").pack(side=tk.LEFT)
        self.scan_type_var = tk.StringVar(value="code_analysis")
        
        scan_types = [
            ("Code Analysis", "code_analysis"),
            ("Dependency Check", "dependency_check"),
            ("Web Application", "web_app"),
            ("Comprehensive", "comprehensive")
        ]
        
        for text, value in scan_types:
            ttk.Radiobutton(scan_type_frame, text=text, variable=self.scan_type_var, 
                           value=value).pack(side=tk.LEFT, padx=(10, 0))
        
        # Scan options
        options_frame = ttk.Frame(config_frame)
        options_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.include_cve_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(options_frame, text="Include CVE Database Check", 
                       variable=self.include_cve_var).pack(side=tk.LEFT)
        
        self.deep_scan_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(options_frame, text="Deep Scan (Slower)", 
                       variable=self.deep_scan_var).pack(side=tk.LEFT, padx=(20, 0))
        
        # Control buttons
        button_frame = ttk.Frame(config_frame)
        button_frame.pack(fill=tk.X, pady=(10, 0))
        
        self.scan_button = ttk.Button(button_frame, text="Start Scan", 
                                     command=self.start_scan)
        self.scan_button.pack(side=tk.LEFT)
        
        self.stop_button = ttk.Button(button_frame, text="Stop Scan", 
                                     command=self.stop_scan, state=tk.DISABLED)
        self.stop_button.pack(side=tk.LEFT, padx=(10, 0))
        
        ttk.Button(button_frame, text="Export Results", 
                  command=self.export_results).pack(side=tk.RIGHT)
        
        # Progress bar
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(main_frame, variable=self.progress_var, 
                                          maximum=100)
        self.progress_bar.pack(fill=tk.X, pady=(10, 0))
        
        # Status label
        self.status_var = tk.StringVar(value="Ready to scan")
        status_label = ttk.Label(main_frame, textvariable=self.status_var)
        status_label.pack(pady=(5, 10))
        
        # Results notebook
        self.results_notebook = ttk.Notebook(main_frame)
        self.results_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Summary tab
        self.setup_summary_tab()
        
        # Vulnerabilities tab
        self.setup_vulnerabilities_tab()
        
        # Dependencies tab
        self.setup_dependencies_tab()
        
        # Recommendations tab
        self.setup_recommendations_tab()
        
        self.scan_thread = None
        self.stop_scan_flag = False
        
    def setup_summary_tab(self):
        """Setup the summary results tab"""
        summary_frame = ttk.Frame(self.results_notebook)
        self.results_notebook.add(summary_frame, text="Summary")
        
        # Summary text widget
        self.summary_text = scrolledtext.ScrolledText(summary_frame, wrap=tk.WORD, 
                                                     height=15, width=80)
        self.summary_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
    def setup_vulnerabilities_tab(self):
        """Setup the vulnerabilities results tab"""
        vuln_frame = ttk.Frame(self.results_notebook)
        self.results_notebook.add(vuln_frame, text="Vulnerabilities")
        
        # Vulnerabilities treeview
        columns = ("Severity", "Type", "File", "Line", "Description")
        self.vuln_tree = ttk.Treeview(vuln_frame, columns=columns, show="headings", height=15)
        
        for col in columns:
            self.vuln_tree.heading(col, text=col)
            self.vuln_tree.column(col, width=120)
        
        # Scrollbars for treeview
        vuln_scrollbar_y = ttk.Scrollbar(vuln_frame, orient=tk.VERTICAL, 
                                        command=self.vuln_tree.yview)
        vuln_scrollbar_x = ttk.Scrollbar(vuln_frame, orient=tk.HORIZONTAL, 
                                        command=self.vuln_tree.xview)
        self.vuln_tree.configure(yscrollcommand=vuln_scrollbar_y.set, 
                                xscrollcommand=vuln_scrollbar_x.set)
        
        # Pack treeview and scrollbars
        self.vuln_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(10, 0), pady=10)
        vuln_scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y, pady=10)
        vuln_scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X, padx=10)
        
        # Bind double-click to show details
        self.vuln_tree.bind("<Double-1>", self.show_vulnerability_details)
        
    def setup_dependencies_tab(self):
        """Setup the dependencies results tab"""
        deps_frame = ttk.Frame(self.results_notebook)
        self.results_notebook.add(deps_frame, text="Dependencies")
        
        # Dependencies treeview
        columns = ("Package", "Version", "Vulnerabilities", "Risk Level", "Update Available")
        self.deps_tree = ttk.Treeview(deps_frame, columns=columns, show="headings", height=15)
        
        for col in columns:
            self.deps_tree.heading(col, text=col)
            self.deps_tree.column(col, width=120)
        
        # Scrollbars
        deps_scrollbar_y = ttk.Scrollbar(deps_frame, orient=tk.VERTICAL, 
                                        command=self.deps_tree.yview)
        self.deps_tree.configure(yscrollcommand=deps_scrollbar_y.set)
        
        self.deps_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(10, 0), pady=10)
        deps_scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y, pady=10)
        
    def setup_recommendations_tab(self):
        """Setup the recommendations tab"""
        rec_frame = ttk.Frame(self.results_notebook)
        self.results_notebook.add(rec_frame, text="Recommendations")
        
        # Recommendations text widget
        self.recommendations_text = scrolledtext.ScrolledText(rec_frame, wrap=tk.WORD, 
                                                            height=15, width=80)
        self.recommendations_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
    def load_vulnerability_patterns(self) -> Dict[str, List[Dict]]:
        """Load OWASP Top 10 and common vulnerability patterns"""
        patterns = {
            "injection": [
                {
                    "name": "SQL Injection - String Concatenation",
                    "pattern": r"(execute|query|select|insert|update|delete)\s*\(\s*[\"'].*\+.*[\"']\s*\)",
                    "severity": "High",
                    "description": "Potential SQL injection via string concatenation",
                    "remediation": "Use parameterized queries or prepared statements"
                },
                {
                    "name": "SQL Injection - String Formatting",
                    "pattern": r"(execute|query|select|insert|update|delete)\s*\(\s*[\"'].*%[sd].*[\"']\s*%",
                    "severity": "High",
                    "description": "SQL injection via string formatting",
                    "remediation": "Use parameterized queries instead of string formatting"
                },
                {
                    "name": "SQL Injection - f-string",
                    "pattern": r"(execute|query|select|insert|update|delete)\s*\(\s*f[\"'].*\{.*\}.*[\"']\s*\)",
                    "severity": "High",
                    "description": "SQL injection via f-string formatting",
                    "remediation": "Use parameterized queries instead of f-string formatting"
                },
                {
                    "name": "Command Injection - os.system",
                    "pattern": r"os\.system\s*\(\s*.*\+.*\)",
                    "severity": "Critical",
                    "description": "Command injection via os.system with user input",
                    "remediation": "Use subprocess with shell=False and validate inputs"
                },
                {
                    "name": "Command Injection - subprocess",
                    "pattern": r"subprocess\.(call|run|Popen)\s*\(\s*.*\+.*shell\s*=\s*True",
                    "severity": "Critical",
                    "description": "Command injection via subprocess with shell=True",
                    "remediation": "Avoid shell=True, use list arguments instead"
                },
                {
                    "name": "Code Injection - exec",
                    "pattern": r"exec\s*\(\s*.*\+.*\)",
                    "severity": "Critical",
                    "description": "Code injection via exec() with user input",
                    "remediation": "Avoid exec() with user input, use safe alternatives"
                },
                {
                    "name": "Code Injection - eval",
                    "pattern": r"eval\s*\(\s*.*\+.*\)",
                    "severity": "Critical",
                    "description": "Code injection via eval() with user input",
                    "remediation": "Avoid eval() with user input, use ast.literal_eval() for safe evaluation"
                },
                {
                    "name": "LDAP Injection",
                    "pattern": r"ldap.*search.*\+.*user",
                    "severity": "High",
                    "description": "Potential LDAP injection vulnerability",
                    "remediation": "Sanitize LDAP query inputs and use parameterized queries"
                },
                {
                    "name": "NoSQL Injection - MongoDB",
                    "pattern": r"(find|findOne|aggregate)\s*\(\s*\{.*\$.*user",
                    "severity": "High",
                    "description": "Potential NoSQL injection vulnerability",
                    "remediation": "Validate and sanitize NoSQL query parameters"
                },
                {
                    "name": "XPath Injection",
                    "pattern": r"xpath.*\+.*user",
                    "severity": "High",
                    "description": "Potential XPath injection vulnerability",
                    "remediation": "Use parameterized XPath queries and input validation"
                }
            ],
            "broken_authentication": [
                {
                    "name": "Hardcoded Password",
                    "pattern": r"(password|pwd|pass)\s*=\s*[\"'][^\"']+[\"']",
                    "severity": "High",
                    "description": "Hardcoded password found in source code",
                    "remediation": "Use environment variables or secure credential storage"
                },
                {
                    "name": "Hardcoded Secret Key",
                    "pattern": r"(secret|secret_key|api_key)\s*=\s*[\"'][^\"']{8,}[\"']",
                    "severity": "High",
                    "description": "Hardcoded secret key found",
                    "remediation": "Use environment variables or secure key management"
                },
                {
                    "name": "Weak Password Policy",
                    "pattern": r"password.*length.*[<>=]\s*[1-7]",
                    "severity": "Medium",
                    "description": "Weak password length requirement (less than 8 characters)",
                    "remediation": "Implement strong password policies (min 8 characters, complexity requirements)"
                },
                {
                    "name": "Missing Session Timeout",
                    "pattern": r"session.*timeout.*=.*None|session.*permanent.*=.*True",
                    "severity": "Medium",
                    "description": "Session timeout not configured or permanent sessions enabled",
                    "remediation": "Configure appropriate session timeouts (15-30 minutes for sensitive apps)"
                },
                {
                    "name": "Weak JWT Secret",
                    "pattern": r"jwt.*secret.*=.*[\"'][^\"']{1,31}[\"']",
                    "severity": "High",
                    "description": "Weak JWT secret key detected (less than 32 characters)",
                    "remediation": "Use strong, randomly generated JWT secrets (min 32 characters)"
                },
                {
                    "name": "Default Credentials",
                    "pattern": r"(admin|root|user).*password.*=.*(admin|password|123456|root)",
                    "severity": "Critical",
                    "description": "Default or common credentials detected",
                    "remediation": "Change default credentials and use strong, unique passwords"
                },
                {
                    "name": "Insecure Authentication Storage",
                    "pattern": r"(password|credential).*=.*request\.(form|args|json)",
                    "severity": "Medium",
                    "description": "Credentials stored directly from request without hashing",
                    "remediation": "Hash passwords using bcrypt, scrypt, or Argon2 before storage"
                }
            ],
            "sensitive_data": [
                {
                    "name": "API Key Exposure",
                    "pattern": r"(api[_-]?key|apikey|access[_-]?token)\s*[=:]\s*[\"'][^\"']+[\"']",
                    "severity": "High",
                    "description": "Potential API key exposure",
                    "remediation": "Store API keys securely, use environment variables"
                },
                {
                    "name": "Database Connection String",
                    "pattern": r"(connection[_-]?string|conn[_-]?str).*password.*=",
                    "severity": "High",
                    "description": "Database connection string with embedded credentials",
                    "remediation": "Use secure configuration management"
                },
                {
                    "name": "Private Key Exposure",
                    "pattern": r"-----BEGIN (RSA |DSA |EC )?PRIVATE KEY-----",
                    "severity": "Critical",
                    "description": "Private key found in source code",
                    "remediation": "Remove private keys from source code, use secure key management"
                },
                {
                    "name": "AWS Credentials",
                    "pattern": r"(aws[_-]?access[_-]?key[_-]?id|aws[_-]?secret[_-]?access[_-]?key)\s*[=:]\s*[\"'][^\"']+[\"']",
                    "severity": "Critical",
                    "description": "AWS credentials found in source code",
                    "remediation": "Use IAM roles or AWS credential files, never hardcode credentials"
                },
                {
                    "name": "Credit Card Numbers",
                    "pattern": r"\b(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13}|3[0-9]{13}|6(?:011|5[0-9]{2})[0-9]{12})\b",
                    "severity": "Critical",
                    "description": "Potential credit card number found",
                    "remediation": "Remove sensitive financial data, implement proper data masking"
                },
                {
                    "name": "Social Security Numbers",
                    "pattern": r"\b\d{3}-\d{2}-\d{4}\b",
                    "severity": "Critical",
                    "description": "Potential Social Security Number found",
                    "remediation": "Remove PII data, implement data anonymization"
                }
            ],
            "xml_external_entities": [
                {
                    "name": "XXE Vulnerability",
                    "pattern": r"XMLParser.*resolve_entities.*True",
                    "severity": "High",
                    "description": "XML External Entity (XXE) vulnerability",
                    "remediation": "Disable XML external entity processing"
                }
            ],
            "broken_access_control": [
                {
                    "name": "Missing Authorization Check",
                    "pattern": r"@app\.route.*methods.*POST.*\n(?!.*@login_required)(?!.*@auth)",
                    "severity": "Medium",
                    "description": "POST endpoint without authorization check",
                    "remediation": "Add proper authorization checks to all endpoints"
                }
            ],
            "security_misconfiguration": [
                {
                    "name": "Debug Mode Enabled",
                    "pattern": r"debug\s*=\s*True|DEBUG\s*=\s*True",
                    "severity": "Medium",
                    "description": "Debug mode enabled - may expose sensitive information",
                    "remediation": "Disable debug mode in production environments"
                },
                {
                    "name": "Insecure Random - Python",
                    "pattern": r"random\.random\(\)|random\.randint\(|random\.choice\(",
                    "severity": "Medium",
                    "description": "Use of insecure random number generator for security purposes",
                    "remediation": "Use secrets module or os.urandom() for cryptographic randomness"
                },
                {
                    "name": "Insecure Random - JavaScript",
                    "pattern": r"Math\.random\(\)",
                    "severity": "Medium",
                    "description": "Use of insecure Math.random() for security purposes",
                    "remediation": "Use crypto.getRandomValues() for cryptographic randomness"
                },
                {
                    "name": "HTTP URLs in Production",
                    "pattern": r"http://(?!localhost|127\.0\.0\.1|0\.0\.0\.0)",
                    "severity": "Medium",
                    "description": "HTTP URL found, should use HTTPS in production",
                    "remediation": "Use HTTPS for all external communications"
                },
                {
                    "name": "Weak SSL/TLS Configuration",
                    "pattern": r"ssl.*version.*=.*(SSLv2|SSLv3|TLSv1\.0|TLSv1\.1)",
                    "severity": "High",
                    "description": "Weak SSL/TLS version configured",
                    "remediation": "Use TLS 1.2 or higher, disable weak protocols"
                },
                {
                    "name": "Insecure Cookie - Missing Secure",
                    "pattern": r"set_cookie\([^)]*\)(?!.*secure\s*=\s*True)",
                    "severity": "Medium",
                    "description": "Cookie without secure flag",
                    "remediation": "Set secure=True for cookies transmitted over HTTPS"
                },
                {
                    "name": "Insecure Cookie - Missing HttpOnly",
                    "pattern": r"set_cookie\([^)]*\)(?!.*httponly\s*=\s*True)",
                    "severity": "Medium",
                    "description": "Cookie without HttpOnly flag",
                    "remediation": "Set httponly=True to prevent XSS access to cookies"
                },
                {
                    "name": "CORS Wildcard",
                    "pattern": r"Access-Control-Allow-Origin.*\*",
                    "severity": "Medium",
                    "description": "CORS configured with wildcard origin",
                    "remediation": "Specify explicit allowed origins instead of wildcard"
                },
                {
                    "name": "Exposed Server Information",
                    "pattern": r"Server:\s*(Apache|nginx|IIS)\/[\d\.]+",
                    "severity": "Low",
                    "description": "Server version information exposed",
                    "remediation": "Hide server version information in HTTP headers"
                },
                {
                    "name": "Missing CSRF Protection",
                    "pattern": r"@app\.route.*methods.*POST.*(?!.*csrf)",
                    "severity": "Medium",
                    "description": "POST endpoint without CSRF protection",
                    "remediation": "Implement CSRF tokens for state-changing operations"
                }
            ],
            "xss": [
                {
                    "name": "Potential XSS",
                    "pattern": r"innerHTML\s*=.*\+|document\.write\s*\(.*\+",
                    "severity": "Medium",
                    "description": "Potential Cross-Site Scripting (XSS) vulnerability",
                    "remediation": "Sanitize user input and use safe DOM manipulation"
                },
                {
                    "name": "Template Injection",
                    "pattern": r"render_template_string\s*\(.*\+|Template\s*\(.*\+",
                    "severity": "High",
                    "description": "Potential template injection vulnerability",
                    "remediation": "Avoid dynamic template construction, sanitize template variables"
                },
                {
                    "name": "Unsafe HTML Rendering",
                    "pattern": r"mark_safe\s*\(.*\+|safe\s*\|.*\+",
                    "severity": "Medium",
                    "description": "Unsafe HTML rendering with user input",
                    "remediation": "Sanitize user input before marking as safe"
                },
                {
                    "name": "DOM XSS",
                    "pattern": r"location\.(href|hash|search)\s*=.*\+|window\.open\s*\(.*\+",
                    "severity": "Medium",
                    "description": "Potential DOM-based XSS vulnerability",
                    "remediation": "Validate and sanitize URL parameters and fragments"
                }
            ],
            "insecure_deserialization": [
                {
                    "name": "Unsafe Deserialization",
                    "pattern": r"pickle\.loads?\(|yaml\.load\((?!.*Loader=yaml\.SafeLoader)",
                    "severity": "High",
                    "description": "Unsafe deserialization detected",
                    "remediation": "Use safe deserialization methods or validate input"
                },
                {
                    "name": "Unsafe JSON Deserialization",
                    "pattern": r"json\.loads?\(.*request\.|eval\s*\(\s*.*json",
                    "severity": "Medium",
                    "description": "Potentially unsafe JSON deserialization",
                    "remediation": "Validate JSON structure and content before deserialization"
                },
                {
                    "name": "Unsafe XML Parsing",
                    "pattern": r"xml\.etree\.ElementTree\.parse\(.*user|lxml\.etree\.parse\(.*user",
                    "severity": "High",
                    "description": "Unsafe XML parsing with user input",
                    "remediation": "Use secure XML parsers and disable external entity processing"
                }
            ],
            "components_with_vulnerabilities": [
                {
                    "name": "Outdated Dependencies",
                    "pattern": r"requirements\.txt|package\.json|Gemfile",
                    "severity": "Info",
                    "description": "Dependency file found - check for vulnerabilities",
                    "remediation": "Regularly update dependencies and check for CVEs"
                }
            ],
            "insufficient_logging": [
                {
                    "name": "Missing Security Logging",
                    "pattern": r"(login|authentication|authorization).*(?!.*log)",
                    "severity": "Low",
                    "description": "Security-sensitive operation without logging",
                    "remediation": "Add comprehensive security event logging"
                }
            ],
            "cryptographic_failures": [
                {
                    "name": "Weak Hash - MD5",
                    "pattern": r"hashlib\.md5\(|crypto\.createHash\([\"']md5[\"']\)|md5\(",
                    "severity": "High",
                    "description": "Use of cryptographically broken MD5 hash algorithm",
                    "remediation": "Use SHA-256, SHA-3, or bcrypt for password hashing"
                },
                {
                    "name": "Weak Hash - SHA1",
                    "pattern": r"hashlib\.sha1\(|crypto\.createHash\([\"']sha1[\"']\)|sha1\(",
                    "severity": "Medium",
                    "description": "Use of weak SHA-1 hash algorithm",
                    "remediation": "Use SHA-256 or stronger hash algorithms"
                },
                {
                    "name": "Weak Encryption - DES",
                    "pattern": r"DES\.new\(|Cipher\.DES|\"DES\"|'DES'",
                    "severity": "Critical",
                    "description": "Use of broken DES encryption algorithm",
                    "remediation": "Use AES-256 with secure modes (GCM, CBC with HMAC)"
                },
                {
                    "name": "Weak Encryption - 3DES",
                    "pattern": r"3DES|TripleDES|DES3",
                    "severity": "High",
                    "description": "Use of deprecated 3DES encryption algorithm",
                    "remediation": "Use AES-256 with secure modes"
                },
                {
                    "name": "Weak Encryption - RC4",
                    "pattern": r"RC4|ARC4|ARCFOUR",
                    "severity": "Critical",
                    "description": "Use of broken RC4 stream cipher",
                    "remediation": "Use AES with secure modes or ChaCha20-Poly1305"
                },
                {
                    "name": "Insecure AES Mode - ECB",
                    "pattern": r"AES.*ECB|MODE_ECB",
                    "severity": "High",
                    "description": "Use of insecure AES ECB mode",
                    "remediation": "Use AES with CBC, GCM, or CTR modes with proper IV"
                },
                {
                    "name": "Hardcoded Encryption Key",
                    "pattern": r"(key|aes_key|encryption_key)\s*=\s*[\"'][0-9a-fA-F]{16,}[\"']",
                    "severity": "Critical",
                    "description": "Hardcoded encryption key found",
                    "remediation": "Generate keys dynamically, use key derivation functions"
                },
                {
                    "name": "Hardcoded IV/Salt",
                    "pattern": r"(iv|salt|nonce)\s*=\s*[\"'][0-9a-fA-F]{8,}[\"']",
                    "severity": "High",
                    "description": "Hardcoded IV, salt, or nonce found",
                    "remediation": "Generate random IVs/salts for each encryption operation"
                },
                {
                    "name": "Weak Key Size",
                    "pattern": r"(key_size|keysize)\s*=\s*(64|128)(?!.*256)",
                    "severity": "Medium",
                    "description": "Weak encryption key size detected",
                    "remediation": "Use minimum 256-bit keys for symmetric encryption"
                },
                {
                    "name": "Insecure Random for Crypto",
                    "pattern": r"(key|iv|salt|nonce).*random\.random|random\.randint",
                    "severity": "High",
                    "description": "Insecure random number generator used for cryptographic material",
                    "remediation": "Use cryptographically secure random generators (os.urandom, secrets)"
                }
            ],
            "server_side_request_forgery": [
                {
                    "name": "SSRF Vulnerability",
                    "pattern": r"requests\.(get|post|put|delete)\s*\(\s*.*user|urllib\.request\.urlopen\s*\(\s*.*user",
                    "severity": "High",
                    "description": "Potential Server-Side Request Forgery vulnerability",
                    "remediation": "Validate and whitelist URLs, use URL parsing libraries"
                }
            ],
            "path_traversal": [
                {
                    "name": "Path Traversal",
                    "pattern": r"open\s*\(\s*.*\+.*user|file\s*\(\s*.*\+.*user",
                    "severity": "High",
                    "description": "Potential path traversal vulnerability",
                    "remediation": "Validate file paths and use safe file access methods"
                },
                {
                    "name": "Directory Traversal",
                    "pattern": r"\.\.\/|\.\.\\\\",
                    "severity": "Medium",
                    "description": "Directory traversal pattern detected",
                    "remediation": "Sanitize file paths and restrict file access"
                }
            ],
            "race_conditions": [
                {
                    "name": "Time-of-Check Time-of-Use",
                    "pattern": r"os\.path\.exists\s*\(.*\).*open\s*\(",
                    "severity": "Medium",
                    "description": "Potential TOCTOU race condition",
                    "remediation": "Use atomic file operations or proper locking"
                }
            ],
            "information_disclosure": [
                {
                    "name": "Stack Trace Exposure",
                    "pattern": r"traceback\.print_exc\(\)|console\.error\(.*error\)",
                    "severity": "Low",
                    "description": "Potential stack trace exposure",
                    "remediation": "Log errors securely, don't expose stack traces to users"
                },
                {
                    "name": "Sensitive Data in Logs",
                    "pattern": r"log.*password|log.*token|log.*key",
                    "severity": "Medium",
                    "description": "Potential sensitive data in logs",
                    "remediation": "Sanitize log data, avoid logging sensitive information"
                }
            ]
        }
        return patterns    
    
    def browse_target(self):
        """Browse for target file or directory"""
        target_type = messagebox.askyesno("Target Type", 
                                         "Select 'Yes' for directory, 'No' for file")
        
        if target_type:
            target = filedialog.askdirectory(title="Select Directory to Scan")
        else:
            target = filedialog.askopenfilename(
                title="Select File to Scan",
                filetypes=[
                    ("Python files", "*.py"),
                    ("JavaScript files", "*.js"),
                    ("All files", "*.*")
                ]
            )
        
        if target:
            self.target_var.set(target)
    
    def start_scan(self):
        """Start the vulnerability scan"""
        target = self.target_var.get().strip()
        if not target:
            messagebox.showerror("Error", "Please specify a target to scan")
            return
        
        if not os.path.exists(target):
            messagebox.showerror("Error", "Target path does not exist")
            return
        
        # Input validation
        is_safe, safety_message = self.security_utils.validate_input_safety(target, "vulnerability_scan")
        if not is_safe:
            messagebox.showerror("Input Validation Error", safety_message)
            return
        
        # Validate target for ethical scanning
        if not self.validate_and_authorize(target, "vulnerability_scan"):
            messagebox.showerror("Authorization Error", 
                               "Target not authorized for scanning. Check security logs.")
            return
        
        # Rate limiting check
        is_within_limit, limit_message = self.security_utils.rate_limit_check("vulnerability_scan", 5, 300)
        if not is_within_limit:
            messagebox.showerror("Rate Limit", limit_message)
            return
        
        # Start scan in separate thread
        self.stop_scan_flag = False
        self.scan_thread = threading.Thread(target=self.run_scan, args=(target,))
        self.scan_thread.daemon = True
        self.scan_thread.start()
        
        # Update UI state
        self.scan_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.NORMAL)
        self.status_var.set("Scanning...")
        self.progress_var.set(0)
    
    def stop_scan(self):
        """Stop the current scan"""
        self.stop_scan_flag = True
        self.status_var.set("Stopping scan...")
        
    def run_scan(self, target: str):
        """Run the vulnerability scan"""
        try:
            self.log_security_activity("SCAN_STARTED", f"Vulnerability scan started", target)
            
            scan_type = self.scan_type_var.get()
            self.scan_results = []
            
            if scan_type in ["code_analysis", "comprehensive"]:
                self.scan_code_vulnerabilities(target)
            
            if scan_type in ["dependency_check", "comprehensive"]:
                self.scan_dependencies(target)
            
            if scan_type in ["web_app", "comprehensive"]:
                self.scan_web_application(target)
            
            # Update UI with results
            self.master.after(0, self.update_results_ui)
            
            self.log_security_activity("SCAN_COMPLETED", 
                                     f"Vulnerability scan completed. Found {len(self.scan_results)} issues", 
                                     target)
            
        except Exception as e:
            self.log_security_activity("SCAN_ERROR", f"Scan error: {str(e)}", target)
            self.master.after(0, lambda: messagebox.showerror("Scan Error", str(e)))
        
        finally:
            # Reset UI state
            self.master.after(0, self.reset_scan_ui)
    
    def scan_code_vulnerabilities(self, target: str):
        """Scan for code vulnerabilities using pattern matching"""
        if os.path.isfile(target):
            files_to_scan = [target]
        else:
            files_to_scan = []
            for root, dirs, files in os.walk(target):
                if self.stop_scan_flag:
                    break
                for file in files:
                    if file.endswith(('.py', '.js', '.php', '.java', '.cpp', '.c')):
                        files_to_scan.append(os.path.join(root, file))
        
        total_files = len(files_to_scan)
        
        for i, file_path in enumerate(files_to_scan):
            if self.stop_scan_flag:
                break
                
            # Update progress
            progress = (i / total_files) * 50  # 50% for code scan
            self.master.after(0, lambda p=progress: self.progress_var.set(p))
            
            try:
                self.scan_file_vulnerabilities(file_path)
            except Exception as e:
                self.log_security_activity("FILE_SCAN_ERROR", 
                                         f"Error scanning {file_path}: {str(e)}")
    
    def scan_file_vulnerabilities(self, file_path: str):
        """Scan a single file for vulnerabilities"""
        try:
            # Check file size to avoid scanning very large files
            file_size = os.path.getsize(file_path)
            if file_size > 10 * 1024 * 1024:  # 10MB limit
                self.log_security_activity("FILE_SKIPPED", 
                                         f"File too large, skipped: {file_path} ({file_size} bytes)")
                return
            
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # Skip empty files
            if not content.strip():
                return
            
            # Scan for each vulnerability category
            vulnerabilities_found = 0
            for category, patterns in self.vulnerability_patterns.items():
                if self.stop_scan_flag:
                    break
                    
                for pattern_info in patterns:
                    try:
                        matches = re.finditer(pattern_info["pattern"], content, 
                                            re.MULTILINE | re.IGNORECASE)
                        
                        for match in matches:
                            if self.stop_scan_flag:
                                break
                                
                            line_num = content[:match.start()].count('\n') + 1
                            
                            # Avoid duplicate findings on the same line
                            existing_vuln = any(
                                v["file"] == file_path and 
                                v["line"] == line_num and 
                                v["type"] == pattern_info["name"]
                                for v in self.scan_results
                            )
                            
                            if not existing_vuln:
                                vulnerability = {
                                    "type": pattern_info["name"],
                                    "category": category,
                                    "severity": pattern_info["severity"],
                                    "file": file_path,
                                    "line": line_num,
                                    "description": pattern_info["description"],
                                    "remediation": pattern_info["remediation"],
                                    "code_snippet": self.get_code_snippet(content, line_num),
                                    "matched_text": match.group(0)[:100],  # First 100 chars
                                    "timestamp": datetime.now().isoformat()
                                }
                                
                                self.scan_results.append(vulnerability)
                                vulnerabilities_found += 1
                                
                    except re.error as regex_error:
                        self.log_security_activity("PATTERN_ERROR", 
                                                 f"Regex error in pattern {pattern_info['name']}: {str(regex_error)}")
            
            if vulnerabilities_found > 0:
                self.log_security_activity("VULNERABILITIES_FOUND", 
                                         f"Found {vulnerabilities_found} vulnerabilities in {file_path}")
                        
        except UnicodeDecodeError:
            self.log_security_activity("FILE_ENCODING_ERROR", 
                                     f"Encoding error reading {file_path}, skipping")
        except PermissionError:
            self.log_security_activity("FILE_PERMISSION_ERROR", 
                                     f"Permission denied reading {file_path}")
        except Exception as e:
            self.log_security_activity("FILE_SCAN_ERROR", 
                                     f"Error scanning {file_path}: {str(e)}")
    
    def get_code_snippet(self, content: str, line_num: int, context: int = 2) -> str:
        """Get code snippet around the vulnerability"""
        lines = content.split('\n')
        start = max(0, line_num - context - 1)
        end = min(len(lines), line_num + context)
        
        snippet_lines = []
        for i in range(start, end):
            marker = ">>> " if i == line_num - 1 else "    "
            snippet_lines.append(f"{marker}{i+1}: {lines[i]}")
        
        return '\n'.join(snippet_lines)
    
    def scan_dependencies(self, target: str):
        """Scan dependencies for known vulnerabilities"""
        dependency_files = []
        
        if os.path.isfile(target):
            if target.endswith(('requirements.txt', 'package.json', 'Gemfile')):
                dependency_files.append(target)
        else:
            for root, dirs, files in os.walk(target):
                for file in files:
                    if file in ['requirements.txt', 'package.json', 'Gemfile', 'pom.xml']:
                        dependency_files.append(os.path.join(root, file))
        
        for dep_file in dependency_files:
            if self.stop_scan_flag:
                break
            self.scan_dependency_file(dep_file)
        
        # Update progress
        self.master.after(0, lambda: self.progress_var.set(75))
    
    def scan_dependency_file(self, file_path: str):
        """Scan a dependency file for vulnerabilities"""
        try:
            if file_path.endswith('requirements.txt'):
                self.scan_python_requirements(file_path)
            elif file_path.endswith('package.json'):
                self.scan_npm_dependencies(file_path)
            # Add more dependency types as needed
                
        except Exception as e:
            self.log_security_activity("DEPENDENCY_SCAN_ERROR", 
                                     f"Error scanning {file_path}: {str(e)}")
    
    def scan_python_requirements(self, file_path: str):
        """Scan Python requirements.txt for vulnerabilities"""
        try:
            with open(file_path, 'r') as f:
                requirements = f.readlines()
            
            for line_num, requirement in enumerate(requirements, 1):
                requirement = requirement.strip()
                if not requirement or requirement.startswith('#'):
                    continue
                
                # Parse package name and version
                package_info = self.parse_python_requirement(requirement)
                if package_info:
                    # Check for known vulnerabilities (mock implementation)
                    vulnerabilities = self.check_package_vulnerabilities(
                        package_info['name'], package_info['version'], 'python'
                    )
                    
                    if vulnerabilities:
                        for vuln in vulnerabilities:
                            vulnerability = {
                                "type": "Vulnerable Dependency",
                                "category": "components_with_vulnerabilities",
                                "severity": vuln.get("severity", "Medium"),
                                "file": file_path,
                                "line": line_num,
                                "description": f"Package {package_info['name']} {package_info['version']} has known vulnerabilities",
                                "remediation": f"Update to version {vuln.get('fixed_version', 'latest')}",
                                "cve_id": vuln.get("cve_id", ""),
                                "timestamp": datetime.now().isoformat()
                            }
                            self.scan_results.append(vulnerability)
                            
        except Exception as e:
            self.log_security_activity("PYTHON_REQ_ERROR", f"Error scanning Python requirements: {str(e)}")
    
    def parse_python_requirement(self, requirement: str) -> Optional[Dict]:
        """Parse Python requirement string"""
        # Simple parsing - can be enhanced
        import re
        match = re.match(r'^([a-zA-Z0-9_-]+)([>=<!=]+)?([\d.]+)?', requirement)
        if match:
            return {
                'name': match.group(1),
                'operator': match.group(2) or '==',
                'version': match.group(3) or 'latest'
            }
        return None
    
    def scan_npm_dependencies(self, file_path: str):
        """Scan package.json for vulnerabilities"""
        try:
            with open(file_path, 'r') as f:
                package_data = json.load(f)
            
            dependencies = package_data.get('dependencies', {})
            dev_dependencies = package_data.get('devDependencies', {})
            
            all_deps = {**dependencies, **dev_dependencies}
            
            for package_name, version in all_deps.items():
                vulnerabilities = self.check_package_vulnerabilities(
                    package_name, version, 'npm'
                )
                
                if vulnerabilities:
                    for vuln in vulnerabilities:
                        vulnerability = {
                            "type": "Vulnerable NPM Package",
                            "category": "components_with_vulnerabilities", 
                            "severity": vuln.get("severity", "Medium"),
                            "file": file_path,
                            "line": 0,
                            "description": f"NPM package {package_name} {version} has known vulnerabilities",
                            "remediation": f"Update to version {vuln.get('fixed_version', 'latest')}",
                            "cve_id": vuln.get("cve_id", ""),
                            "timestamp": datetime.now().isoformat()
                        }
                        self.scan_results.append(vulnerability)
                        
        except Exception as e:
            self.log_security_activity("NPM_SCAN_ERROR", f"Error scanning NPM dependencies: {str(e)}")
    
    def check_package_vulnerabilities(self, package_name: str, version: str, 
                                    ecosystem: str) -> List[Dict]:
        """Check package for known vulnerabilities"""
        if not self.include_cve_var.get():
            return []
        
        # Check cache first
        cache_key = f"{ecosystem}:{package_name}:{version}"
        if cache_key in self.cve_cache:
            self.log_security_activity("CVE_CACHE_HIT", f"Using cached CVE data for {cache_key}")
            return self.cve_cache[cache_key]
        
        vulnerabilities = []
        
        try:
            # Rate limit CVE queries
            is_within_limit, _ = self.security_utils.rate_limit_check("cve_query", 30, 60)
            if not is_within_limit:
                self.log_security_activity("CVE_RATE_LIMITED", f"CVE query rate limited for {package_name}")
                vulnerabilities = self.get_mock_vulnerabilities(package_name, version)
            else:
                # Try to query OSV (Open Source Vulnerabilities) database
                vulnerabilities = self.query_osv_database(package_name, version, ecosystem)
                
        except requests.RequestException as e:
            self.log_security_activity("CVE_NETWORK_ERROR", f"Network error querying CVE database: {str(e)}")
            vulnerabilities = self.get_mock_vulnerabilities(package_name, version)
        except Exception as e:
            self.log_security_activity("CVE_QUERY_ERROR", f"Error querying CVE database: {str(e)}")
            vulnerabilities = self.get_mock_vulnerabilities(package_name, version)
        
        # Cache the results with timestamp
        self.cve_cache[cache_key] = vulnerabilities
        
        if vulnerabilities:
            self.log_security_activity("CVE_VULNERABILITIES_FOUND", 
                                     f"Found {len(vulnerabilities)} CVEs for {package_name} {version}")
        
        return vulnerabilities
    
    def query_osv_database(self, package_name: str, version: str, ecosystem: str) -> List[Dict]:
        """Query OSV database for vulnerabilities"""
        try:
            # Map ecosystem names to OSV format
            ecosystem_map = {
                'python': 'PyPI',
                'npm': 'npm',
                'maven': 'Maven',
                'nuget': 'NuGet',
                'go': 'Go',
                'ruby': 'RubyGems'
            }
            
            osv_ecosystem = ecosystem_map.get(ecosystem.lower(), ecosystem)
            
            # Prepare OSV API request
            osv_url = "https://api.osv.dev/v1/query"
            query_data = {
                "package": {
                    "name": package_name,
                    "ecosystem": osv_ecosystem
                },
                "version": version
            }
            
            # Make API request with timeout
            response = requests.post(osv_url, json=query_data, timeout=10)
            
            if response.status_code == 200:
                osv_data = response.json()
                vulnerabilities = []
                
                for vuln in osv_data.get('vulns', []):
                    severity = self.extract_severity_from_osv(vuln)
                    fixed_version = self.extract_fixed_version_from_osv(vuln, ecosystem)
                    
                    vulnerability = {
                        'cve_id': vuln.get('id', 'Unknown'),
                        'severity': severity,
                        'description': vuln.get('summary', 'No description available'),
                        'fixed_version': fixed_version,
                        'published': vuln.get('published', ''),
                        'modified': vuln.get('modified', ''),
                        'source': 'OSV'
                    }
                    vulnerabilities.append(vulnerability)
                
                return vulnerabilities
            else:
                self.log_security_activity("OSV_API_ERROR", 
                                         f"OSV API returned status {response.status_code} for {package_name}")
                return self.get_mock_vulnerabilities(package_name, version)
                
        except requests.Timeout:
            self.log_security_activity("OSV_TIMEOUT", f"OSV API timeout for {package_name}")
            return self.get_mock_vulnerabilities(package_name, version)
        except Exception as e:
            self.log_security_activity("OSV_ERROR", f"OSV API error for {package_name}: {str(e)}")
            return self.get_mock_vulnerabilities(package_name, version)
    
    def extract_severity_from_osv(self, vuln_data: Dict) -> str:
        """Extract severity from OSV vulnerability data"""
        # Check for CVSS score
        severity_info = vuln_data.get('severity', [])
        if severity_info:
            for severity in severity_info:
                if severity.get('type') == 'CVSS_V3':
                    score = severity.get('score', 0)
                    if score >= 9.0:
                        return 'Critical'
                    elif score >= 7.0:
                        return 'High'
                    elif score >= 4.0:
                        return 'Medium'
                    else:
                        return 'Low'
        
        # Fallback to database specific severity
        database_specific = vuln_data.get('database_specific', {})
        severity = database_specific.get('severity', 'Medium')
        return severity.title()
    
    def extract_fixed_version_from_osv(self, vuln_data: Dict, ecosystem: str) -> str:
        """Extract fixed version from OSV vulnerability data"""
        affected = vuln_data.get('affected', [])
        for affected_item in affected:
            ranges = affected_item.get('ranges', [])
            for range_item in ranges:
                events = range_item.get('events', [])
                for event in events:
                    if 'fixed' in event:
                        return event['fixed']
        
        # Check versions array for fixed versions
        for affected_item in affected:
            versions = affected_item.get('versions', [])
            if versions:
                # Return the last version as a potential fixed version
                return f">{versions[-1]}"
        
        return 'latest'
    
    def get_mock_vulnerabilities(self, package_name: str, version: str) -> List[Dict]:
        """Get mock vulnerability data for demonstration"""
        mock_vulnerabilities = {
            'requests': {
                '2.25.0': [
                    {
                        'cve_id': 'CVE-2021-33503',
                        'severity': 'High',
                        'description': 'Catastrophic backtracking in URL parsing',
                        'fixed_version': '2.25.1'
                    }
                ],
                '2.20.0': [
                    {
                        'cve_id': 'CVE-2018-18074',
                        'severity': 'Medium',
                        'description': 'Redirect vulnerability',
                        'fixed_version': '2.20.1'
                    }
                ]
            },
            'django': {
                '3.1.0': [
                    {
                        'cve_id': 'CVE-2021-35042',
                        'severity': 'Medium',
                        'description': 'Potential directory traversal',
                        'fixed_version': '3.1.13'
                    }
                ],
                '2.2.0': [
                    {
                        'cve_id': 'CVE-2019-14232',
                        'severity': 'High',
                        'description': 'Denial-of-service in django.utils.text.Truncator',
                        'fixed_version': '2.2.4'
                    }
                ]
            },
            'flask': {
                '1.0.0': [
                    {
                        'cve_id': 'CVE-2018-1000656',
                        'severity': 'High',
                        'description': 'Improper Input Validation vulnerability',
                        'fixed_version': '1.0.1'
                    }
                ]
            },
            'numpy': {
                '1.16.0': [
                    {
                        'cve_id': 'CVE-2019-6446',
                        'severity': 'Medium',
                        'description': 'Buffer overflow in parsing of malformed .npy files',
                        'fixed_version': '1.16.1'
                    }
                ]
            },
            'pillow': {
                '6.2.0': [
                    {
                        'cve_id': 'CVE-2019-16865',
                        'severity': 'High',
                        'description': 'Buffer overflow in image processing',
                        'fixed_version': '6.2.1'
                    }
                ]
            }
        }
        
        return mock_vulnerabilities.get(package_name, {}).get(version, [])
    
    def scan_web_application(self, target: str):
        """Scan web application for vulnerabilities"""
        self.master.after(0, lambda: self.progress_var.set(85))
        
        if os.path.isdir(target):
            # Scan for web application files and configurations
            self.scan_web_config_files(target)
            self.scan_web_templates(target)
            self.scan_web_static_files(target)
        
        self.master.after(0, lambda: self.progress_var.set(90))
    
    def scan_web_config_files(self, target: str):
        """Scan web application configuration files"""
        config_patterns = {
            "Exposed Configuration File": {
                "files": [".env", "config.ini", "settings.py", "web.config", "app.config"],
                "severity": "Medium",
                "description": "Configuration file may contain sensitive information",
                "remediation": "Ensure configuration files are not accessible via web and contain no secrets"
            },
            "Database Configuration Exposure": {
                "pattern": r"(database|db).*=.*(password|pwd|pass)",
                "severity": "High",
                "description": "Database credentials found in configuration",
                "remediation": "Use environment variables for database credentials"
            },
            "API Key in Config": {
                "pattern": r"(api_key|apikey|secret_key).*=.*[\"'][^\"']{10,}[\"']",
                "severity": "High",
                "description": "API key found in configuration file",
                "remediation": "Move API keys to environment variables or secure vault"
            }
        }
        
        for root, dirs, files in os.walk(target):
            if self.stop_scan_flag:
                break
                
            for file in files:
                file_path = os.path.join(root, file)
                
                # Check for exposed config files
                for pattern_name, pattern_info in config_patterns.items():
                    if "files" in pattern_info and file in pattern_info["files"]:
                        vulnerability = {
                            "type": pattern_name,
                            "category": "security_misconfiguration",
                            "severity": pattern_info["severity"],
                            "file": file_path,
                            "line": 0,
                            "description": pattern_info["description"],
                            "remediation": pattern_info["remediation"],
                            "timestamp": datetime.now().isoformat()
                        }
                        self.scan_results.append(vulnerability)
                    
                    # Check file contents for patterns
                    elif "pattern" in pattern_info and file.endswith(('.ini', '.conf', '.config', '.env', '.py')):
                        try:
                            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                content = f.read()
                            
                            matches = re.finditer(pattern_info["pattern"], content, re.IGNORECASE)
                            for match in matches:
                                line_num = content[:match.start()].count('\n') + 1
                                vulnerability = {
                                    "type": pattern_name,
                                    "category": "sensitive_data",
                                    "severity": pattern_info["severity"],
                                    "file": file_path,
                                    "line": line_num,
                                    "description": pattern_info["description"],
                                    "remediation": pattern_info["remediation"],
                                    "code_snippet": self.get_code_snippet(content, line_num),
                                    "timestamp": datetime.now().isoformat()
                                }
                                self.scan_results.append(vulnerability)
                        except Exception:
                            continue
    
    def scan_web_templates(self, target: str):
        """Scan web application templates for XSS vulnerabilities"""
        template_extensions = ['.html', '.htm', '.jsp', '.php', '.asp', '.aspx', '.erb', '.ejs', '.twig']
        
        xss_patterns = {
            "Unsafe Template Variable": {
                "pattern": r"\{\{\s*[^}]*\|safe\s*\}\}|\{\{\s*[^}]*\|raw\s*\}\}",
                "severity": "Medium",
                "description": "Template variable marked as safe without sanitization",
                "remediation": "Ensure user input is properly sanitized before marking as safe"
            },
            "Direct HTML Output": {
                "pattern": r"<%=\s*[^%]*%>|<\?=\s*[^?]*\?>",
                "severity": "Medium",
                "description": "Direct output to HTML without escaping",
                "remediation": "Use proper HTML escaping functions"
            },
            "JavaScript in Template": {
                "pattern": r"<script[^>]*>.*\{\{.*\}\}.*</script>",
                "severity": "High",
                "description": "User data directly embedded in JavaScript",
                "remediation": "Use JSON encoding and proper escaping for JavaScript context"
            }
        }
        
        for root, dirs, files in os.walk(target):
            if self.stop_scan_flag:
                break
                
            for file in files:
                if any(file.endswith(ext) for ext in template_extensions):
                    file_path = os.path.join(root, file)
                    
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                        
                        for pattern_name, pattern_info in xss_patterns.items():
                            matches = re.finditer(pattern_info["pattern"], content, re.IGNORECASE | re.DOTALL)
                            for match in matches:
                                line_num = content[:match.start()].count('\n') + 1
                                vulnerability = {
                                    "type": pattern_name,
                                    "category": "xss",
                                    "severity": pattern_info["severity"],
                                    "file": file_path,
                                    "line": line_num,
                                    "description": pattern_info["description"],
                                    "remediation": pattern_info["remediation"],
                                    "code_snippet": self.get_code_snippet(content, line_num),
                                    "timestamp": datetime.now().isoformat()
                                }
                                self.scan_results.append(vulnerability)
                    except Exception:
                        continue
    
    def scan_web_static_files(self, target: str):
        """Scan static web files for information disclosure"""
        sensitive_files = [
            '.git', '.svn', '.hg', 'CVS',  # Version control
            'backup', 'bak', 'old', 'tmp',  # Backup files
            '.DS_Store', 'Thumbs.db',  # System files
            'web.config', '.htaccess', 'robots.txt',  # Config files
            'phpinfo.php', 'info.php',  # Info disclosure
            'test.php', 'debug.php', 'admin.php'  # Test/debug files
        ]
        
        for root, dirs, files in os.walk(target):
            if self.stop_scan_flag:
                break
                
            # Check directories
            for dir_name in dirs:
                if any(sensitive in dir_name.lower() for sensitive in sensitive_files):
                    dir_path = os.path.join(root, dir_name)
                    vulnerability = {
                        "type": "Sensitive Directory Exposed",
                        "category": "security_misconfiguration",
                        "severity": "Medium",
                        "file": dir_path,
                        "line": 0,
                        "description": f"Potentially sensitive directory: {dir_name}",
                        "remediation": "Ensure sensitive directories are not web-accessible",
                        "timestamp": datetime.now().isoformat()
                    }
                    self.scan_results.append(vulnerability)
            
            # Check files
            for file_name in files:
                if any(sensitive in file_name.lower() for sensitive in sensitive_files):
                    file_path = os.path.join(root, file_name)
                    vulnerability = {
                        "type": "Sensitive File Exposed",
                        "category": "security_misconfiguration",
                        "severity": "Medium",
                        "file": file_path,
                        "line": 0,
                        "description": f"Potentially sensitive file: {file_name}",
                        "remediation": "Ensure sensitive files are not web-accessible",
                        "timestamp": datetime.now().isoformat()
                    }
                    self.scan_results.append(vulnerability)
    
    def update_results_ui(self):
        """Update the UI with scan results"""
        # Clear previous results
        self.clear_results()
        
        # Update summary
        self.update_summary()
        
        # Update vulnerabilities tree
        self.update_vulnerabilities_tree()
        
        # Update dependencies tree
        self.update_dependencies_tree()
        
        # Update recommendations
        self.update_recommendations()
        
        # Save results to database
        self.save_scan_results()
        
        # Final progress update
        self.progress_var.set(100)
        self.status_var.set(f"Scan completed - Found {len(self.scan_results)} issues")
    
    def clear_results(self):
        """Clear all result displays"""
        self.summary_text.delete(1.0, tk.END)
        
        for item in self.vuln_tree.get_children():
            self.vuln_tree.delete(item)
        
        for item in self.deps_tree.get_children():
            self.deps_tree.delete(item)
        
        self.recommendations_text.delete(1.0, tk.END)
    
    def update_summary(self):
        """Update the summary tab"""
        if not self.scan_results:
            self.summary_text.insert(tk.END, "No vulnerabilities found.\n")
            return
        
        # Count by severity
        severity_counts = {}
        category_counts = {}
        
        for result in self.scan_results:
            severity = result.get("severity", "Unknown")
            category = result.get("category", "unknown")
            
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
            category_counts[category] = category_counts.get(category, 0) + 1
        
        # Generate summary
        summary = f"Vulnerability Scan Summary\n"
        summary += f"=" * 50 + "\n\n"
        summary += f"Total Issues Found: {len(self.scan_results)}\n\n"
        
        summary += "Severity Breakdown:\n"
        for severity in ["Critical", "High", "Medium", "Low", "Info"]:
            count = severity_counts.get(severity, 0)
            if count > 0:
                summary += f"  {severity}: {count}\n"
        
        summary += "\nCategory Breakdown:\n"
        for category, count in category_counts.items():
            category_name = category.replace("_", " ").title()
            summary += f"  {category_name}: {count}\n"
        
        summary += f"\nScan completed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        
        self.summary_text.insert(tk.END, summary)
    
    def update_vulnerabilities_tree(self):
        """Update the vulnerabilities tree view"""
        for result in self.scan_results:
            if result.get("category") != "components_with_vulnerabilities":
                self.vuln_tree.insert("", tk.END, values=(
                    result.get("severity", "Unknown"),
                    result.get("type", "Unknown"),
                    os.path.basename(result.get("file", "")),
                    result.get("line", ""),
                    result.get("description", "")[:50] + "..."
                ))
    
    def update_dependencies_tree(self):
        """Update the dependencies tree view"""
        dep_results = [r for r in self.scan_results 
                      if r.get("category") == "components_with_vulnerabilities"]
        
        for result in dep_results:
            self.deps_tree.insert("", tk.END, values=(
                result.get("type", "Unknown"),
                "N/A",  # Version would be parsed from description
                "1",    # Number of vulnerabilities
                result.get("severity", "Unknown"),
                "Available"  # Update status
            ))
    
    def update_recommendations(self):
        """Update the recommendations tab"""
        if not self.scan_results:
            self.recommendations_text.insert(tk.END, "No specific recommendations at this time.\n")
            return
        
        recommendations = "Security Recommendations\n"
        recommendations += "=" * 50 + "\n\n"
        
        # Group by severity and provide recommendations
        critical_high = [r for r in self.scan_results 
                        if r.get("severity") in ["Critical", "High"]]
        
        if critical_high:
            recommendations += "IMMEDIATE ACTION REQUIRED:\n"
            recommendations += "-" * 30 + "\n"
            for result in critical_high[:5]:  # Top 5 critical/high
                recommendations += f"• {result.get('type', 'Unknown')}\n"
                recommendations += f"  File: {result.get('file', 'Unknown')}\n"
                recommendations += f"  Remediation: {result.get('remediation', 'Review manually')}\n\n"
        
        # Category-specific recommendations
        categories_found = set(r.get("category", "unknown") for r in self.scan_results)
        
        if "injection" in categories_found:
            recommendations += "\nINJECTION VULNERABILITIES:\n"
            recommendations += "• Use parameterized queries for database operations\n"
            recommendations += "• Implement input validation and sanitization\n"
            recommendations += "• Use ORM frameworks with built-in protection\n"
            recommendations += "• Avoid dynamic command construction\n\n"
        
        if "broken_authentication" in categories_found:
            recommendations += "AUTHENTICATION ISSUES:\n"
            recommendations += "• Implement strong password policies\n"
            recommendations += "• Use multi-factor authentication\n"
            recommendations += "• Secure session management\n"
            recommendations += "• Regular credential rotation\n\n"
        
        if "sensitive_data" in categories_found:
            recommendations += "SENSITIVE DATA EXPOSURE:\n"
            recommendations += "• Use environment variables for secrets\n"
            recommendations += "• Implement proper data encryption\n"
            recommendations += "• Regular secret scanning\n"
            recommendations += "• Secure key management practices\n\n"
        
        if "cryptographic_failures" in categories_found:
            recommendations += "CRYPTOGRAPHIC ISSUES:\n"
            recommendations += "• Use modern, secure algorithms (AES-256, SHA-256+)\n"
            recommendations += "• Implement proper key management\n"
            recommendations += "• Use secure random number generators\n"
            recommendations += "• Regular cryptographic reviews\n\n"
        
        # General recommendations
        recommendations += "GENERAL SECURITY RECOMMENDATIONS:\n"
        recommendations += "-" * 35 + "\n"
        recommendations += "• Regularly update all dependencies\n"
        recommendations += "• Implement automated security scanning in CI/CD\n"
        recommendations += "• Conduct regular security code reviews\n"
        recommendations += "• Use static analysis tools in development\n"
        recommendations += "• Implement comprehensive logging and monitoring\n"
        recommendations += "• Follow OWASP secure coding guidelines\n"
        recommendations += "• Regular security training for developers\n"
        recommendations += "• Implement defense in depth strategies\n"
        
        self.recommendations_text.insert(tk.END, recommendations)
    
    def show_vulnerability_details(self, event):
        """Show detailed information about selected vulnerability"""
        selection = self.vuln_tree.selection()
        if not selection:
            return
        
        item = self.vuln_tree.item(selection[0])
        values = item['values']
        
        # Find the corresponding result
        for result in self.scan_results:
            if (result.get("severity") == values[0] and 
                result.get("type") == values[1] and
                os.path.basename(result.get("file", "")) == values[2]):
                
                self.show_vulnerability_popup(result)
                break
    
    def show_vulnerability_popup(self, vulnerability: Dict):
        """Show detailed vulnerability information in popup"""
        popup = tk.Toplevel(self.master)
        popup.title("Vulnerability Details")
        popup.geometry("600x500")
        
        # Create scrolled text widget
        text_widget = scrolledtext.ScrolledText(popup, wrap=tk.WORD)
        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Format vulnerability details
        details = f"Vulnerability Details\n"
        details += "=" * 50 + "\n\n"
        details += f"Type: {vulnerability.get('type', 'Unknown')}\n"
        details += f"Severity: {vulnerability.get('severity', 'Unknown')}\n"
        details += f"Category: {vulnerability.get('category', 'Unknown')}\n"
        details += f"File: {vulnerability.get('file', 'Unknown')}\n"
        details += f"Line: {vulnerability.get('line', 'Unknown')}\n\n"
        details += f"Description:\n{vulnerability.get('description', 'No description available')}\n\n"
        details += f"Remediation:\n{vulnerability.get('remediation', 'No remediation available')}\n\n"
        
        if vulnerability.get('code_snippet'):
            details += f"Code Snippet:\n"
            details += "-" * 20 + "\n"
            details += vulnerability['code_snippet'] + "\n\n"
        
        if vulnerability.get('cve_id'):
            details += f"CVE ID: {vulnerability['cve_id']}\n"
        
        text_widget.insert(tk.END, details)
        text_widget.config(state=tk.DISABLED)
    
    def reset_scan_ui(self):
        """Reset UI state after scan completion"""
        self.scan_button.config(state=tk.NORMAL)
        self.stop_button.config(state=tk.DISABLED)
        self.is_authorized = False  # Reset authorization
    
    def export_results(self):
        """Export scan results to file"""
        if not self.scan_results:
            messagebox.showwarning("No Results", "No scan results to export")
            return
        
        file_path = filedialog.asksaveasfilename(
            title="Export Scan Results",
            defaultextension=".json",
            filetypes=[
                ("JSON files", "*.json"),
                ("CSV files", "*.csv"),
                ("Text files", "*.txt")
            ]
        )
        
        if not file_path:
            return
        
        try:
            if file_path.endswith('.json'):
                self.export_json(file_path)
            elif file_path.endswith('.csv'):
                self.export_csv(file_path)
            else:
                self.export_text(file_path)
            
            messagebox.showinfo("Export Complete", f"Results exported to {file_path}")
            
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export results: {str(e)}")
    
    def export_json(self, file_path: str):
        """Export results as JSON"""
        export_data = {
            "scan_metadata": {
                "timestamp": datetime.now().isoformat(),
                "target": self.target_var.get(),
                "scan_type": self.scan_type_var.get(),
                "total_issues": len(self.scan_results)
            },
            "vulnerabilities": self.scan_results
        }
        
        with open(file_path, 'w') as f:
            json.dump(export_data, f, indent=2)
    
    def export_csv(self, file_path: str):
        """Export results as CSV"""
        import csv
        
        with open(file_path, 'w', newline='') as f:
            writer = csv.writer(f)
            
            # Write header
            writer.writerow([
                "Type", "Severity", "Category", "File", "Line", 
                "Description", "Remediation", "CVE ID", "Timestamp"
            ])
            
            # Write data
            for result in self.scan_results:
                writer.writerow([
                    result.get("type", ""),
                    result.get("severity", ""),
                    result.get("category", ""),
                    result.get("file", ""),
                    result.get("line", ""),
                    result.get("description", ""),
                    result.get("remediation", ""),
                    result.get("cve_id", ""),
                    result.get("timestamp", "")
                ])
    
    def export_text(self, file_path: str):
        """Export results as text"""
        with open(file_path, 'w') as f:
            f.write("Security Vulnerability Scan Report\n")
            f.write("=" * 50 + "\n\n")
            f.write(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Target: {self.target_var.get()}\n")
            f.write(f"Scan Type: {self.scan_type_var.get()}\n")
            f.write(f"Total Issues: {len(self.scan_results)}\n\n")
            
            for i, result in enumerate(self.scan_results, 1):
                f.write(f"Issue #{i}\n")
                f.write("-" * 20 + "\n")
                f.write(f"Type: {result.get('type', 'Unknown')}\n")
                f.write(f"Severity: {result.get('severity', 'Unknown')}\n")
                f.write(f"File: {result.get('file', 'Unknown')}\n")
                f.write(f"Line: {result.get('line', 'Unknown')}\n")
                f.write(f"Description: {result.get('description', 'No description')}\n")
                f.write(f"Remediation: {result.get('remediation', 'No remediation')}\n\n")
    
    def save_scan_results(self):
        """Save scan results to database"""
        try:
            scan_metadata = {
                "scan_id": hashlib.md5(f"{self.target_var.get()}{datetime.now().isoformat()}".encode()).hexdigest(),
                "target": self.target_var.get(),
                "scan_type": self.scan_type_var.get(),
                "timestamp": datetime.now().isoformat(),
                "total_issues": len(self.scan_results),
                "severity_counts": self.get_severity_counts()
            }
            
            # Save to database using DatabaseManager
            self.db_manager.save_analysis_result(
                analysis_id=scan_metadata["scan_id"],
                tool_id="SecurityVulnerabilityScanner",
                input_data={"target": scan_metadata["target"], "scan_type": scan_metadata["scan_type"]},
                results_summary=scan_metadata,
                detailed_findings=self.scan_results,
                recommendations=[],
                metrics=scan_metadata.get("severity_counts", {}),
                export_formats=["json", "csv", "txt"]
            )
            
            self.log_security_activity("SCAN_RESULTS_SAVED", 
                                     f"Saved {len(self.scan_results)} vulnerabilities to database")
            
        except Exception as e:
            self.log_security_activity("DATABASE_SAVE_ERROR", 
                                     f"Error saving scan results: {str(e)}")
    
    def get_severity_counts(self) -> Dict[str, int]:
        """Get count of vulnerabilities by severity"""
        severity_counts = {}
        for result in self.scan_results:
            severity = result.get("severity", "Unknown")
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        return severity_counts


class ToolFrame(SecurityVulnerabilityScanner):
    """Alias for compatibility with main.py tool loading"""
    pass

# Tool registration
def create_tool(master):
    return SecurityVulnerabilityScanner(master)

if __name__ == "__main__":
    # Test the tool
    root = tk.Tk()
    tool = SecurityVulnerabilityScanner(root)
    root.mainloop()